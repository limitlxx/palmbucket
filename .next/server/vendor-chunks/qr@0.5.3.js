"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/qr@0.5.3";
exports.ids = ["vendor-chunks/qr@0.5.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/qr@0.5.3/node_modules/qr/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/.pnpm/qr@0.5.3/node_modules/qr/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bitmap: () => (/* binding */ Bitmap),\n/* harmony export */   ECMode: () => (/* binding */ ECMode),\n/* harmony export */   Encoding: () => (/* binding */ Encoding),\n/* harmony export */   _tests: () => (/* binding */ _tests),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   encodeQR: () => (/* binding */ encodeQR),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*!\nCopyright (c) 2023 Paul Miller (paulmillr.com)\nThe library paulmillr-qr is dual-licensed under the Apache 2.0 OR MIT license.\nYou can select a license of your choice.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Methods for encoding (generating) QR code patterns.\n * Check out decode.ts for decoding (reading).\n * @module\n * @example\n```js\nimport encodeQR from 'qr';\nconst txt = 'Hello world';\nconst ascii = encodeQR(txt, 'ascii'); // Not all fonts are supported\nconst terminalFriendly = encodeQR(txt, 'term'); // 2x larger, all fonts are OK\nconst gifBytes = encodeQR(txt, 'gif'); // Uncompressed GIF\nconst svgElement = encodeQR(txt, 'svg'); // SVG vector image element\nconst array = encodeQR(txt, 'raw'); // 2d array for canvas or other libs\n// import decodeQR from 'qr/decode.js';\n```\n */\nconst R1_RUN_LENGTH_THRESHOLD = 5;\nconst R2_BLOCK_PENALTY = 3;\nconst R3_FINDER_PATTERN_LENGTH = 11;\nconst R3_FINDER_PENALTY = 40;\nconst R4_BALANCE_STEP_PERCENT = 5;\nconst R4_BALANCE_STEP_POINTS = 10;\n// We do not use newline escape code directly in strings because it's not parser-friendly\nconst chCodes = { newline: 10, reset: 27 };\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`integer expected: ${n}`);\n}\nfunction validateVersion(ver) {\n    if (!Number.isSafeInteger(ver) || ver < 1 || ver > 40)\n        throw new Error(`Invalid version=${ver}. Expected number [1..40]`);\n}\nfunction bin(dec, pad) {\n    return dec.toString(2).padStart(pad, '0');\n}\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction fillArr(length, val) {\n    return new Array(length).fill(val);\n}\n/**\n * Interleaves byte blocks.\n * @param blocks [[1, 2, 3], [4, 5, 6]]\n * @returns [1, 4, 2, 5, 3, 6]\n */\nfunction interleaveBytes(blocks) {\n    let maxLen = 0;\n    let totalLen = 0;\n    for (const block of blocks) {\n        maxLen = Math.max(maxLen, block.length);\n        totalLen += block.length;\n    }\n    const result = new Uint8Array(totalLen);\n    let idx = 0;\n    for (let i = 0; i < maxLen; i++) {\n        for (const block of blocks) {\n            if (i < block.length)\n                result[idx++] = block[i];\n        }\n    }\n    return result;\n}\n// Optimize for minimal score/penalty\nfunction best() {\n    let best;\n    let bestScore = Infinity;\n    return {\n        add(score, value) {\n            if (score >= bestScore)\n                return;\n            best = value;\n            bestScore = score;\n        },\n        get: () => best,\n        score: () => bestScore,\n    };\n}\n// Based on https://github.com/paulmillr/scure-base/blob/main/index.ts\nfunction alphabet(alphabet) {\n    return {\n        has: (char) => alphabet.includes(char),\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n    };\n}\nclass Bitmap {\n    static size(size, limit) {\n        if (typeof size === 'number')\n            size = { height: size, width: size };\n        if (!Number.isSafeInteger(size.height) && size.height !== Infinity)\n            throw new Error(`Bitmap: invalid height=${size.height} (${typeof size.height})`);\n        if (!Number.isSafeInteger(size.width) && size.width !== Infinity)\n            throw new Error(`Bitmap: invalid width=${size.width} (${typeof size.width})`);\n        if (limit !== undefined) {\n            // Clamp length, so it won't overflow, also allows to use Infinity, so we draw until end\n            size = {\n                width: Math.min(size.width, limit.width),\n                height: Math.min(size.height, limit.height),\n            };\n        }\n        return size;\n    }\n    static fromString(s) {\n        // Remove linebreaks on start and end, so we draw in `` section\n        s = s.replace(/^\\n+/g, '').replace(/\\n+$/g, '');\n        const lines = s.split(String.fromCharCode(chCodes.newline));\n        const height = lines.length;\n        const data = new Array(height);\n        let width;\n        for (const line of lines) {\n            const row = line.split('').map((i) => {\n                if (i === 'X')\n                    return true;\n                if (i === ' ')\n                    return false;\n                if (i === '?')\n                    return undefined;\n                throw new Error(`Bitmap.fromString: unknown symbol=${i}`);\n            });\n            if (width && row.length !== width)\n                throw new Error(`Bitmap.fromString different row sizes: width=${width} cur=${row.length}`);\n            width = row.length;\n            data.push(row);\n        }\n        if (!width)\n            width = 0;\n        return new Bitmap({ height, width }, data);\n    }\n    data;\n    height;\n    width;\n    constructor(size, data) {\n        const { height, width } = Bitmap.size(size);\n        this.data = data || Array.from({ length: height }, () => fillArr(width, undefined));\n        this.height = height;\n        this.width = width;\n    }\n    point(p) {\n        return this.data[p.y][p.x];\n    }\n    isInside(p) {\n        return 0 <= p.x && p.x < this.width && 0 <= p.y && p.y < this.height;\n    }\n    size(offset) {\n        if (!offset)\n            return { height: this.height, width: this.width };\n        const { x, y } = this.xy(offset);\n        return { height: this.height - y, width: this.width - x };\n    }\n    xy(c) {\n        if (typeof c === 'number')\n            c = { x: c, y: c };\n        if (!Number.isSafeInteger(c.x))\n            throw new Error(`Bitmap: invalid x=${c.x}`);\n        if (!Number.isSafeInteger(c.y))\n            throw new Error(`Bitmap: invalid y=${c.y}`);\n        // Do modulo, so we can use negative positions\n        c.x = mod(c.x, this.width);\n        c.y = mod(c.y, this.height);\n        return c;\n    }\n    // Basically every operation can be represented as rect\n    rect(c, size, value) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({ x, y }));\n        for (let yPos = 0; yPos < height; yPos++) {\n            for (let xPos = 0; xPos < width; xPos++) {\n                // NOTE: we use give function relative coordinates inside box\n                this.data[y + yPos][x + xPos] =\n                    typeof value === 'function'\n                        ? value({ x: xPos, y: yPos }, this.data[y + yPos][x + xPos])\n                        : value;\n            }\n        }\n        return this;\n    }\n    // returns rectangular part of bitmap\n    rectRead(c, size, fn) {\n        return this.rect(c, size, (c, cur) => {\n            fn(c, cur);\n            return cur;\n        });\n    }\n    // Horizontal & vertical lines\n    hLine(c, len, value) {\n        return this.rect(c, { width: len, height: 1 }, value);\n    }\n    vLine(c, len, value) {\n        return this.rect(c, { width: 1, height: len }, value);\n    }\n    // add border\n    border(border = 2, value) {\n        const height = this.height + 2 * border;\n        const width = this.width + 2 * border;\n        const v = fillArr(border, value);\n        const h = Array.from({ length: border }, () => fillArr(width, value));\n        return new Bitmap({ height, width }, [...h, ...this.data.map((i) => [...v, ...i, ...v]), ...h]);\n    }\n    // Embed another bitmap on coordinates\n    embed(c, bm) {\n        return this.rect(c, bm.size(), ({ x, y }) => bm.data[y][x]);\n    }\n    // returns rectangular part of bitmap\n    rectSlice(c, size = this.size()) {\n        const rect = new Bitmap(Bitmap.size(size, this.size(this.xy(c))));\n        this.rect(c, size, ({ x, y }, cur) => (rect.data[y][x] = cur));\n        return rect;\n    }\n    // Change shape, replace rows with columns (data[y][x] -> data[x][y])\n    inverse() {\n        const { height, width } = this;\n        const res = new Bitmap({ height: width, width: height });\n        return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[x][y]);\n    }\n    // Each pixel size is multiplied by factor\n    scale(factor) {\n        if (!Number.isSafeInteger(factor) || factor > 1024)\n            throw new Error(`invalid scale factor: ${factor}`);\n        const { height, width } = this;\n        const res = new Bitmap({ height: factor * height, width: factor * width });\n        return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.data[Math.floor(y / factor)][Math.floor(x / factor)]);\n    }\n    clone() {\n        const res = new Bitmap(this.size());\n        return res.rect({ x: 0, y: 0 }, this.size(), ({ x, y }) => this.data[y][x]);\n    }\n    // Ensure that there is no undefined values left\n    assertDrawn() {\n        this.rectRead(0, Infinity, (_, cur) => {\n            if (typeof cur !== 'boolean')\n                throw new Error(`Invalid color type=${typeof cur}`);\n        });\n    }\n    // Simple string representation for debugging\n    toString() {\n        return this.data\n            .map((i) => i.map((j) => (j === undefined ? '?' : j ? 'X' : ' ')).join(''))\n            .join(String.fromCharCode(chCodes.newline));\n    }\n    toASCII() {\n        const { height, width, data } = this;\n        let out = '';\n        // Terminal character height is x2 of character width, so we process two rows of bitmap\n        // to produce one row of ASCII\n        for (let y = 0; y < height; y += 2) {\n            for (let x = 0; x < width; x++) {\n                const first = data[y][x];\n                const second = y + 1 >= height ? true : data[y + 1][x]; // if last row outside bitmap, make it black\n                if (!first && !second)\n                    out += '█'; // both rows white (empty)\n                else if (!first && second)\n                    out += '▀'; // top row white\n                else if (first && !second)\n                    out += '▄'; // down row white\n                else if (first && second)\n                    out += ' '; // both rows black\n            }\n            out += String.fromCharCode(chCodes.newline);\n        }\n        return out;\n    }\n    toTerm() {\n        const cc = String.fromCharCode(chCodes.reset);\n        const reset = cc + '[0m';\n        const whiteBG = cc + '[1;47m  ' + reset;\n        const darkBG = cc + `[40m  ` + reset;\n        return this.data\n            .map((i) => i.map((j) => (j ? darkBG : whiteBG)).join(''))\n            .join(String.fromCharCode(chCodes.newline));\n    }\n    toSVG(optimize = true) {\n        let out = `<svg viewBox=\"0 0 ${this.width} ${this.height}\" xmlns=\"http://www.w3.org/2000/svg\">`;\n        // Construct optimized SVG path data.\n        let pathData = '';\n        let prevPoint;\n        this.rectRead(0, Infinity, (point, val) => {\n            if (!val)\n                return;\n            const { x, y } = point;\n            if (!optimize) {\n                out += `<rect x=\"${x}\" y=\"${y}\" width=\"1\" height=\"1\" />`;\n                return;\n            }\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/d#path_commands\n            // Determine the shortest way to represent the initial cursor movement.\n            // M - Move cursor (without drawing) to absolute coordinate pair.\n            let m = `M${x} ${y}`;\n            // Only allow using the relative cursor move command if previous points\n            // were drawn.\n            if (prevPoint) {\n                // m - Move cursor (without drawing) to relative coordinate pair.\n                const relM = `m${x - prevPoint.x} ${y - prevPoint.y}`;\n                if (relM.length <= m.length)\n                    m = relM;\n            }\n            // Determine the shortest way to represent the cell's bottom line draw.\n            // H - Draw line from cursor position to absolute x coordinate.\n            // h - Draw line from cursor position to relative x coordinate.\n            const bH = x < 10 ? `H${x}` : 'h-1';\n            // v - Draw line from cursor position to relative y coordinate.\n            // Z - Close path (draws line from cursor position to M coordinate).\n            pathData += `${m}h1v1${bH}Z`;\n            prevPoint = point;\n        });\n        if (optimize)\n            out += `<path d=\"${pathData}\"/>`;\n        out += `</svg>`;\n        return out;\n    }\n    toGIF() {\n        // NOTE: Small, but inefficient implementation.\n        // Uses 1 byte per pixel.\n        const u16le = (i) => [i & 0xff, (i >>> 8) & 0xff];\n        const dims = [...u16le(this.width), ...u16le(this.height)];\n        const data = [];\n        this.rectRead(0, Infinity, (_, cur) => data.push(+(cur === true)));\n        const N = 126; // Block size\n        // prettier-ignore\n        const bytes = [\n            0x47, 0x49, 0x46, 0x38, 0x37, 0x61, ...dims, 0xf6, 0x00, 0x00, 0xff, 0xff, 0xff,\n            ...fillArr(3 * 127, 0x00), 0x2c, 0x00, 0x00, 0x00, 0x00, ...dims, 0x00, 0x07\n        ];\n        const fullChunks = Math.floor(data.length / N);\n        // Full blocks\n        for (let i = 0; i < fullChunks; i++)\n            bytes.push(N + 1, 0x80, ...data.slice(N * i, N * (i + 1)).map((i) => +i));\n        // Remaining bytes\n        bytes.push((data.length % N) + 1, 0x80, ...data.slice(fullChunks * N).map((i) => +i));\n        bytes.push(0x01, 0x81, 0x00, 0x3b);\n        return new Uint8Array(bytes);\n    }\n    toImage(isRGB = false) {\n        const { height, width } = this.size();\n        const data = new Uint8Array(height * width * (isRGB ? 3 : 4));\n        let i = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const value = !!this.data[y][x] ? 0 : 255;\n                data[i++] = value;\n                data[i++] = value;\n                data[i++] = value;\n                if (!isRGB)\n                    data[i++] = 255; // alpha channel\n            }\n        }\n        return { height, width, data };\n    }\n}\n// End of utils\n// Runtime type-checking\n/** Error correction mode. low: 7%, medium: 15%, quartile: 25%, high: 30% */\nconst ECMode = ['low', 'medium', 'quartile', 'high'];\n/** QR Code encoding */\nconst Encoding = ['numeric', 'alphanumeric', 'byte', 'kanji', 'eci'];\n// Various constants & tables\n// prettier-ignore\nconst BYTES = [\n    // 1,  2,  3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,   20,\n    26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n    //  21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40\n    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,\n];\n// prettier-ignore\nconst WORDS_PER_BLOCK = {\n    // Version 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n    quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n};\n// prettier-ignore\nconst ECC_BLOCKS = {\n    // Version   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n    medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n    quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n    high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],\n};\nconst info = {\n    size: {\n        encode: (ver) => 21 + 4 * (ver - 1), // ver1 = 21, ver40=177 blocks\n        decode: (size) => (size - 17) / 4,\n    },\n    sizeType: (ver) => Math.floor((ver + 7) / 17),\n    // Based on https://codereview.stackexchange.com/questions/74925/algorithm-to-generate-this-alignment-pattern-locations-table-for-qr-codes\n    alignmentPatterns(ver) {\n        if (ver === 1)\n            return [];\n        const first = 6;\n        const last = info.size.encode(ver) - first - 1;\n        const distance = last - first;\n        const count = Math.ceil(distance / 28);\n        let interval = Math.floor(distance / count);\n        if (interval % 2)\n            interval += 1;\n        else if ((distance % count) * 2 >= count)\n            interval += 2;\n        const res = [first];\n        for (let m = 1; m < count; m++)\n            res.push(last - (count - m) * interval);\n        res.push(last);\n        return res;\n    },\n    ECCode: {\n        low: 0b01,\n        medium: 0b00,\n        quartile: 0b11,\n        high: 0b10,\n    },\n    formatMask: 0b101010000010010,\n    formatBits(ecc, maskIdx) {\n        const data = (info.ECCode[ecc] << 3) | maskIdx;\n        let d = data;\n        for (let i = 0; i < 10; i++)\n            d = (d << 1) ^ ((d >> 9) * 0b10100110111);\n        return ((data << 10) | d) ^ info.formatMask;\n    },\n    versionBits(ver) {\n        let d = ver;\n        for (let i = 0; i < 12; i++)\n            d = (d << 1) ^ ((d >> 11) * 0b1111100100101);\n        return (ver << 12) | d;\n    },\n    alphabet: {\n        numeric: alphabet('0123456789'),\n        alphanumerc: alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),\n    }, // as Record<EncodingType, ReturnType<typeof alphabet>>,\n    lengthBits(ver, type) {\n        const table = {\n            numeric: [10, 12, 14],\n            alphanumeric: [9, 11, 13],\n            byte: [8, 16, 16],\n            kanji: [8, 10, 12],\n            eci: [0, 0, 0],\n        };\n        return table[type][info.sizeType(ver)];\n    },\n    modeBits: {\n        numeric: '0001',\n        alphanumeric: '0010',\n        byte: '0100',\n        kanji: '1000',\n        eci: '0111',\n    },\n    capacity(ver, ecc) {\n        const bytes = BYTES[ver - 1];\n        const words = WORDS_PER_BLOCK[ecc][ver - 1];\n        const numBlocks = ECC_BLOCKS[ecc][ver - 1];\n        const blockLen = Math.floor(bytes / numBlocks) - words;\n        const shortBlocks = numBlocks - (bytes % numBlocks);\n        return {\n            words,\n            numBlocks,\n            shortBlocks,\n            blockLen,\n            capacity: (bytes - words * numBlocks) * 8,\n            total: (words + blockLen) * numBlocks + numBlocks - shortBlocks,\n        };\n    },\n};\nconst PATTERNS = [\n    (x, y) => (x + y) % 2 == 0,\n    (_x, y) => y % 2 == 0,\n    (x, _y) => x % 3 == 0,\n    (x, y) => (x + y) % 3 == 0,\n    (x, y) => (Math.floor(y / 2) + Math.floor(x / 3)) % 2 == 0,\n    (x, y) => ((x * y) % 2) + ((x * y) % 3) == 0,\n    (x, y) => (((x * y) % 2) + ((x * y) % 3)) % 2 == 0,\n    (x, y) => (((x + y) % 2) + ((x * y) % 3)) % 2 == 0,\n];\n// Galois field && reed-solomon encoding\nconst GF = {\n    tables: ((p_poly) => {\n        const exp = fillArr(256, 0);\n        const log = fillArr(256, 0);\n        for (let i = 0, x = 1; i < 256; i++) {\n            exp[i] = x;\n            log[x] = i;\n            x <<= 1;\n            if (x & 0x100)\n                x ^= p_poly;\n        }\n        return { exp, log };\n    })(0x11d),\n    exp: (x) => GF.tables.exp[x],\n    log(x) {\n        if (x === 0)\n            throw new Error(`GF.log: invalid arg=${x}`);\n        return GF.tables.log[x] % 255;\n    },\n    mul(x, y) {\n        if (x === 0 || y === 0)\n            return 0;\n        return GF.tables.exp[(GF.tables.log[x] + GF.tables.log[y]) % 255];\n    },\n    add: (x, y) => x ^ y,\n    pow: (x, e) => GF.tables.exp[(GF.tables.log[x] * e) % 255],\n    inv(x) {\n        if (x === 0)\n            throw new Error(`GF.inverse: invalid arg=${x}`);\n        return GF.tables.exp[255 - GF.tables.log[x]];\n    },\n    polynomial(poly) {\n        if (poly.length == 0)\n            throw new Error('GF.polymomial: invalid length');\n        if (poly[0] !== 0)\n            return poly;\n        // Strip leading zeros\n        let i = 0;\n        for (; i < poly.length - 1 && poly[i] == 0; i++)\n            ;\n        return poly.slice(i);\n    },\n    monomial(degree, coefficient) {\n        if (degree < 0)\n            throw new Error(`GF.monomial: invalid degree=${degree}`);\n        if (coefficient == 0)\n            return [0];\n        let coefficients = fillArr(degree + 1, 0);\n        coefficients[0] = coefficient;\n        return GF.polynomial(coefficients);\n    },\n    degree: (a) => a.length - 1,\n    coefficient: (a, degree) => a[GF.degree(a) - degree],\n    mulPoly(a, b) {\n        if (a[0] === 0 || b[0] === 0)\n            return [0];\n        const res = fillArr(a.length + b.length - 1, 0);\n        for (let i = 0; i < a.length; i++) {\n            for (let j = 0; j < b.length; j++) {\n                res[i + j] = GF.add(res[i + j], GF.mul(a[i], b[j]));\n            }\n        }\n        return GF.polynomial(res);\n    },\n    mulPolyScalar(a, scalar) {\n        if (scalar == 0)\n            return [0];\n        if (scalar == 1)\n            return a;\n        const res = fillArr(a.length, 0);\n        for (let i = 0; i < a.length; i++)\n            res[i] = GF.mul(a[i], scalar);\n        return GF.polynomial(res);\n    },\n    mulPolyMonomial(a, degree, coefficient) {\n        if (degree < 0)\n            throw new Error('GF.mulPolyMonomial: invalid degree');\n        if (coefficient == 0)\n            return [0];\n        const res = fillArr(a.length + degree, 0);\n        for (let i = 0; i < a.length; i++)\n            res[i] = GF.mul(a[i], coefficient);\n        return GF.polynomial(res);\n    },\n    addPoly(a, b) {\n        if (a[0] === 0)\n            return b;\n        if (b[0] === 0)\n            return a;\n        let smaller = a;\n        let larger = b;\n        if (smaller.length > larger.length)\n            [smaller, larger] = [larger, smaller];\n        let sumDiff = fillArr(larger.length, 0);\n        let lengthDiff = larger.length - smaller.length;\n        let s = larger.slice(0, lengthDiff);\n        for (let i = 0; i < s.length; i++)\n            sumDiff[i] = s[i];\n        for (let i = lengthDiff; i < larger.length; i++)\n            sumDiff[i] = GF.add(smaller[i - lengthDiff], larger[i]);\n        return GF.polynomial(sumDiff);\n    },\n    remainderPoly(data, divisor) {\n        const out = Array.from(data);\n        for (let i = 0; i < data.length - divisor.length + 1; i++) {\n            const elm = out[i];\n            if (elm === 0)\n                continue;\n            for (let j = 1; j < divisor.length; j++) {\n                if (divisor[j] !== 0)\n                    out[i + j] = GF.add(out[i + j], GF.mul(divisor[j], elm));\n            }\n        }\n        return out.slice(data.length - divisor.length + 1, out.length);\n    },\n    divisorPoly(degree) {\n        let g = [1];\n        for (let i = 0; i < degree; i++)\n            g = GF.mulPoly(g, [1, GF.pow(2, i)]);\n        return g;\n    },\n    evalPoly(poly, a) {\n        if (a == 0)\n            return GF.coefficient(poly, 0); // Just return the x^0 coefficient\n        let res = poly[0];\n        for (let i = 1; i < poly.length; i++)\n            res = GF.add(GF.mul(a, res), poly[i]);\n        return res;\n    },\n    // TODO: cleanup\n    euclidian(a, b, R) {\n        // Force degree(a) >= degree(b)\n        if (GF.degree(a) < GF.degree(b))\n            [a, b] = [b, a];\n        let rLast = a;\n        let r = b;\n        let tLast = [0];\n        let t = [1];\n        // while degree of Ri ≥ t/2\n        while (2 * GF.degree(r) >= R) {\n            let rLastLast = rLast;\n            let tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            if (rLast[0] === 0)\n                throw new Error('rLast[0] === 0');\n            r = rLastLast;\n            let q = [0];\n            const dltInverse = GF.inv(rLast[0]);\n            while (GF.degree(r) >= GF.degree(rLast) && r[0] !== 0) {\n                const degreeDiff = GF.degree(r) - GF.degree(rLast);\n                const scale = GF.mul(r[0], dltInverse);\n                q = GF.addPoly(q, GF.monomial(degreeDiff, scale));\n                r = GF.addPoly(r, GF.mulPolyMonomial(rLast, degreeDiff, scale));\n            }\n            q = GF.mulPoly(q, tLast);\n            t = GF.addPoly(q, tLastLast);\n            if (GF.degree(r) >= GF.degree(rLast))\n                throw new Error(`Division failed r: ${r}, rLast: ${rLast}`);\n        }\n        const sigmaTildeAtZero = GF.coefficient(t, 0);\n        if (sigmaTildeAtZero == 0)\n            throw new Error('sigmaTilde(0) was zero');\n        const inverse = GF.inv(sigmaTildeAtZero);\n        return [GF.mulPolyScalar(t, inverse), GF.mulPolyScalar(r, inverse)];\n    },\n};\nfunction RS(eccWords) {\n    return {\n        encode(from) {\n            const d = GF.divisorPoly(eccWords);\n            const pol = Array.from(from);\n            pol.push(...d.slice(0, -1).fill(0));\n            return Uint8Array.from(GF.remainderPoly(pol, d));\n        },\n        decode(to) {\n            const res = to.slice();\n            const poly = GF.polynomial(Array.from(to));\n            // Find errors\n            let syndrome = fillArr(eccWords, 0);\n            let hasError = false;\n            for (let i = 0; i < eccWords; i++) {\n                const evl = GF.evalPoly(poly, GF.exp(i));\n                syndrome[syndrome.length - 1 - i] = evl;\n                if (evl !== 0)\n                    hasError = true;\n            }\n            if (!hasError)\n                return res;\n            syndrome = GF.polynomial(syndrome);\n            const monomial = GF.monomial(eccWords, 1);\n            const [errorLocator, errorEvaluator] = GF.euclidian(monomial, syndrome, eccWords);\n            // Error locations\n            const locations = fillArr(GF.degree(errorLocator), 0);\n            let e = 0;\n            for (let i = 1; i < 256 && e < locations.length; i++) {\n                if (GF.evalPoly(errorLocator, i) === 0)\n                    locations[e++] = GF.inv(i);\n            }\n            if (e !== locations.length)\n                throw new Error('RS.decode: invalid errors number');\n            for (let i = 0; i < locations.length; i++) {\n                const pos = res.length - 1 - GF.log(locations[i]);\n                if (pos < 0)\n                    throw new Error('RS.decode: invalid error location');\n                const xiInverse = GF.inv(locations[i]);\n                let denominator = 1;\n                for (let j = 0; j < locations.length; j++) {\n                    if (i === j)\n                        continue;\n                    denominator = GF.mul(denominator, GF.add(1, GF.mul(locations[j], xiInverse)));\n                }\n                res[pos] = GF.add(res[pos], GF.mul(GF.evalPoly(errorEvaluator, xiInverse), GF.inv(denominator)));\n            }\n            return res;\n        },\n    };\n}\n// Interleaves blocks\nfunction interleave(ver, ecc) {\n    const { words, shortBlocks, numBlocks, blockLen, total } = info.capacity(ver, ecc);\n    const rs = RS(words);\n    return {\n        encode(bytes) {\n            // Add error correction to bytes\n            const blocks = [];\n            const eccBlocks = [];\n            for (let i = 0; i < numBlocks; i++) {\n                const isShort = i < shortBlocks;\n                const len = blockLen + (isShort ? 0 : 1);\n                blocks.push(bytes.subarray(0, len));\n                eccBlocks.push(rs.encode(bytes.subarray(0, len)));\n                bytes = bytes.subarray(len);\n            }\n            const resBlocks = interleaveBytes(blocks);\n            const resECC = interleaveBytes(eccBlocks);\n            const res = new Uint8Array(resBlocks.length + resECC.length);\n            res.set(resBlocks);\n            res.set(resECC, resBlocks.length);\n            return res;\n        },\n        decode(data) {\n            if (data.length !== total)\n                throw new Error(`interleave.decode: len(data)=${data.length}, total=${total}`);\n            const blocks = [];\n            for (let i = 0; i < numBlocks; i++) {\n                const isShort = i < shortBlocks;\n                blocks.push(new Uint8Array(words + blockLen + (isShort ? 0 : 1)));\n            }\n            // Short blocks\n            let pos = 0;\n            for (let i = 0; i < blockLen; i++) {\n                for (let j = 0; j < numBlocks; j++)\n                    blocks[j][i] = data[pos++];\n            }\n            // Long blocks\n            for (let j = shortBlocks; j < numBlocks; j++)\n                blocks[j][blockLen] = data[pos++];\n            // ECC\n            for (let i = blockLen; i < blockLen + words; i++) {\n                for (let j = 0; j < numBlocks; j++) {\n                    const isShort = j < shortBlocks;\n                    blocks[j][i + (isShort ? 0 : 1)] = data[pos++];\n                }\n            }\n            // Decode\n            // Error-correct and copy data blocks together into a stream of bytes\n            const res = [];\n            for (const block of blocks)\n                res.push(...Array.from(rs.decode(block)).slice(0, -words));\n            return Uint8Array.from(res);\n        },\n    };\n}\n// Draw\n// Generic template per version+ecc+mask. Can be cached, to speedup calculations.\nfunction drawTemplate(ver, ecc, maskIdx, test = false) {\n    const size = info.size.encode(ver);\n    let b = new Bitmap(size + 2);\n    // Finder patterns\n    // We draw full pattern and later slice, since before addition of borders finder is truncated by one pixel on sides\n    const finder = new Bitmap(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);\n    b = b\n        .embed(0, finder) // top left\n        .embed({ x: -finder.width, y: 0 }, finder) // top right\n        .embed({ x: 0, y: -finder.height }, finder); // bottom left\n    b = b.rectSlice(1, size);\n    // Alignment patterns\n    const align = new Bitmap(1).rect(0, 1, true).border(1, false).border(1, true);\n    const alignPos = info.alignmentPatterns(ver);\n    for (const y of alignPos) {\n        for (const x of alignPos) {\n            if (b.data[y][x] !== undefined)\n                continue;\n            b.embed({ x: x - 2, y: y - 2 }, align); // center of pattern should be at position\n        }\n    }\n    // Timing patterns\n    b = b\n        .hLine({ x: 0, y: 6 }, Infinity, ({ x }, cur) => (cur === undefined ? x % 2 == 0 : cur))\n        .vLine({ x: 6, y: 0 }, Infinity, ({ y }, cur) => (cur === undefined ? y % 2 == 0 : cur));\n    // Format information\n    {\n        const bits = info.formatBits(ecc, maskIdx);\n        const getBit = (i) => !test && ((bits >> i) & 1) == 1;\n        // vertical\n        for (let i = 0; i < 6; i++)\n            b.data[i][8] = getBit(i); // right of top-left finder\n        // TODO: re-write as lines, like:\n        // b.vLine({ x: 8, y: 0 }, 6, ({ x, y }) => getBit(y));\n        for (let i = 6; i < 8; i++)\n            b.data[i + 1][8] = getBit(i); // after timing pattern\n        for (let i = 8; i < 15; i++)\n            b.data[size - 15 + i][8] = getBit(i); // right of bottom-left finder\n        // horizontal\n        for (let i = 0; i < 8; i++)\n            b.data[8][size - i - 1] = getBit(i); // under top-right finder\n        for (let i = 8; i < 9; i++)\n            b.data[8][15 - i - 1 + 1] = getBit(i); // VVV, after timing\n        for (let i = 9; i < 15; i++)\n            b.data[8][15 - i - 1] = getBit(i); // under top-left finder\n        b.data[size - 8][8] = !test; // bottom-left finder, right\n    }\n    // Version information\n    if (ver >= 7) {\n        const bits = info.versionBits(ver);\n        for (let i = 0; i < 18; i += 1) {\n            const bit = !test && ((bits >> i) & 1) == 1;\n            const x = Math.floor(i / 3);\n            const y = (i % 3) + size - 8 - 3;\n            // two copies\n            b.data[x][y] = bit;\n            b.data[y][x] = bit;\n        }\n    }\n    return b;\n}\n// zigzag: bottom->top && top->bottom\nfunction zigzag(tpl, maskIdx, fn) {\n    const size = tpl.height;\n    const pattern = PATTERNS[maskIdx];\n    // zig-zag pattern\n    let dir = -1;\n    let y = size - 1;\n    // two columns at time\n    for (let xOffset = size - 1; xOffset > 0; xOffset -= 2) {\n        if (xOffset == 6)\n            xOffset = 5; // skip vertical timing pattern\n        for (;; y += dir) {\n            for (let j = 0; j < 2; j += 1) {\n                const x = xOffset - j;\n                if (tpl.data[y][x] !== undefined)\n                    continue; // skip already written elements\n                fn(x, y, pattern(x, y));\n            }\n            if (y + dir < 0 || y + dir >= size)\n                break;\n        }\n        dir = -dir; // change direction\n    }\n}\n// NOTE: byte encoding is just representation, QR works with strings only. Most decoders will fail on raw byte array,\n// since they expect unicode or other text encoding inside bytes\nfunction detectType(str) {\n    let type = 'numeric';\n    for (let x of str) {\n        if (info.alphabet.numeric.has(x))\n            continue;\n        type = 'alphanumeric';\n        if (!info.alphabet.alphanumerc.has(x))\n            return 'byte';\n    }\n    return type;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nfunction encode(ver, ecc, data, type, encoder = utf8ToBytes) {\n    let encoded = '';\n    let dataLen = data.length;\n    if (type === 'numeric') {\n        const t = info.alphabet.numeric.decode(data.split(''));\n        const n = t.length;\n        for (let i = 0; i < n - 2; i += 3)\n            encoded += bin(t[i] * 100 + t[i + 1] * 10 + t[i + 2], 10);\n        if (n % 3 === 1) {\n            encoded += bin(t[n - 1], 4);\n        }\n        else if (n % 3 === 2) {\n            encoded += bin(t[n - 2] * 10 + t[n - 1], 7);\n        }\n    }\n    else if (type === 'alphanumeric') {\n        const t = info.alphabet.alphanumerc.decode(data.split(''));\n        const n = t.length;\n        for (let i = 0; i < n - 1; i += 2)\n            encoded += bin(t[i] * 45 + t[i + 1], 11);\n        if (n % 2 == 1)\n            encoded += bin(t[n - 1], 6); // pad if odd number of chars\n    }\n    else if (type === 'byte') {\n        const utf8 = encoder(data);\n        dataLen = utf8.length;\n        encoded = Array.from(utf8)\n            .map((i) => bin(i, 8))\n            .join('');\n    }\n    else {\n        throw new Error('encode: unsupported type');\n    }\n    const { capacity } = info.capacity(ver, ecc);\n    const len = bin(dataLen, info.lengthBits(ver, type));\n    let bits = info.modeBits[type] + len + encoded;\n    if (bits.length > capacity)\n        throw new Error('Capacity overflow');\n    // Terminator\n    bits += '0'.repeat(Math.min(4, Math.max(0, capacity - bits.length)));\n    // Pad bits string untill full byte\n    if (bits.length % 8)\n        bits += '0'.repeat(8 - (bits.length % 8));\n    // Add padding until capacity is full\n    const padding = '1110110000010001';\n    for (let idx = 0; bits.length !== capacity; idx++)\n        bits += padding[idx % padding.length];\n    // Convert a bitstring to array of bytes\n    const bytes = Uint8Array.from(bits.match(/(.{8})/g).map((i) => Number(`0b${i}`)));\n    return interleave(ver, ecc).encode(bytes);\n}\n// DRAW\nfunction drawQR(ver, ecc, data, maskIdx, test = false) {\n    const b = drawTemplate(ver, ecc, maskIdx, test);\n    let i = 0;\n    const need = 8 * data.length;\n    zigzag(b, maskIdx, (x, y, mask) => {\n        let value = false;\n        if (i < need) {\n            value = ((data[i >>> 3] >> ((7 - i) & 7)) & 1) !== 0;\n            i++;\n        }\n        b.data[y][x] = value !== mask; // !== as xor\n    });\n    if (i !== need)\n        throw new Error('QR: bytes left after draw');\n    return b;\n}\nfunction calculateRowRunPenalty(rowBits) {\n    const moduleCount = rowBits.length;\n    if (moduleCount <= 1)\n        return 0;\n    let penalty = 0;\n    let runLength = 1;\n    let previousColor = rowBits[0];\n    for (let i = 1; i < moduleCount; i++) {\n        const currentColor = rowBits[i];\n        if (currentColor === previousColor) {\n            runLength++;\n        }\n        else {\n            if (runLength >= R1_RUN_LENGTH_THRESHOLD)\n                penalty += runLength - 2;\n            runLength = 1;\n            previousColor = currentColor;\n        }\n    }\n    if (runLength >= R1_RUN_LENGTH_THRESHOLD)\n        penalty += runLength - 2;\n    return penalty;\n}\nfunction calculateColumnRunPenalty(bitmap, columnIndex, columnHeight) {\n    if (columnHeight <= 1)\n        return 0;\n    let penalty = 0;\n    let runLength = 1;\n    let previousColor = bitmap[0][columnIndex];\n    for (let y = 1; y < columnHeight; y++) {\n        const currentColor = bitmap[y][columnIndex];\n        if (currentColor === previousColor) {\n            runLength++;\n        }\n        else {\n            if (runLength >= R1_RUN_LENGTH_THRESHOLD)\n                penalty += runLength - 2;\n            runLength = 1;\n            previousColor = currentColor;\n        }\n    }\n    if (runLength >= R1_RUN_LENGTH_THRESHOLD)\n        penalty += runLength - 2;\n    return penalty;\n}\nfunction calculateRowFinderPenalty(rowBits) {\n    const rowLength = rowBits.length;\n    if (rowLength < R3_FINDER_PATTERN_LENGTH)\n        return 0;\n    let penalty = 0;\n    const lastStart = rowLength - R3_FINDER_PATTERN_LENGTH;\n    for (let i = 0; i <= lastStart; i++) {\n        // Case A: L L L L + 1 0 1 1 1 0 1\n        const light4ThenFinder7 = !rowBits[i] &&\n            !rowBits[i + 1] &&\n            !rowBits[i + 2] &&\n            !rowBits[i + 3] &&\n            rowBits[i + 4] &&\n            !rowBits[i + 5] &&\n            rowBits[i + 6] &&\n            rowBits[i + 7] &&\n            rowBits[i + 8] &&\n            !rowBits[i + 9] &&\n            rowBits[i + 10];\n        // Case B: 1 0 1 1 1 0 1 + L L L L\n        const finder7ThenLight4 = rowBits[i] &&\n            !rowBits[i + 1] &&\n            rowBits[i + 2] &&\n            rowBits[i + 3] &&\n            rowBits[i + 4] &&\n            !rowBits[i + 5] &&\n            rowBits[i + 6] &&\n            !rowBits[i + 7] &&\n            !rowBits[i + 8] &&\n            !rowBits[i + 9] &&\n            !rowBits[i + 10];\n        if (light4ThenFinder7 || finder7ThenLight4)\n            penalty += R3_FINDER_PENALTY;\n    }\n    return penalty;\n}\nfunction calculateColumnFinderPenalty(matrix, rowIndex, width) {\n    if (width < R3_FINDER_PATTERN_LENGTH)\n        return 0;\n    let penalty = 0;\n    const y = rowIndex;\n    const lastStart = width - R3_FINDER_PATTERN_LENGTH;\n    for (let x = 0; x <= lastStart; x++) {\n        // Case A: L L L L + 1 0 1 1 1 0 1\n        const light4ThenFinder7 = !matrix[x][y] &&\n            !matrix[x + 1][y] &&\n            !matrix[x + 2][y] &&\n            !matrix[x + 3][y] &&\n            matrix[x + 4][y] &&\n            !matrix[x + 5][y] &&\n            matrix[x + 6][y] &&\n            matrix[x + 7][y] &&\n            matrix[x + 8][y] &&\n            !matrix[x + 9][y] &&\n            matrix[x + 10][y];\n        // Case B: 1 0 1 1 1 0 1 + L L L L\n        const finder7ThenLight4 = matrix[x][y] &&\n            !matrix[x + 1][y] &&\n            matrix[x + 2][y] &&\n            matrix[x + 3][y] &&\n            matrix[x + 4][y] &&\n            !matrix[x + 5][y] &&\n            matrix[x + 6][y] &&\n            !matrix[x + 7][y] &&\n            !matrix[x + 8][y] &&\n            !matrix[x + 9][y] &&\n            !matrix[x + 10][y];\n        if (light4ThenFinder7 || finder7ThenLight4)\n            penalty += R3_FINDER_PENALTY;\n    }\n    return penalty;\n}\nfunction penalty(bitmap) {\n    const matrix = bitmap.data;\n    const width = bitmap.width | 0;\n    const height = bitmap.height | 0;\n    if (width === 0 || height === 0)\n        return 0;\n    // Rule 1: same-color runs\n    let runPenalty = 0;\n    for (let x = 0; x < width; x++)\n        runPenalty += calculateRowRunPenalty(matrix[x]);\n    for (let y = 0; y < height; y++)\n        runPenalty += calculateColumnRunPenalty(matrix, y, width);\n    // Rule 2: 2×2 blocks of the same color\n    let blockPenalty = 0;\n    const lastCol = width - 1;\n    const lastRow = height - 1;\n    for (let x = 0; x < lastCol; x++) {\n        const col = matrix[x];\n        const nextCol = matrix[x + 1];\n        for (let y = 0; y < lastRow; y++) {\n            const cell = col[y];\n            if (cell === nextCol[y] && cell === col[y + 1] && cell === nextCol[y + 1]) {\n                blockPenalty += R2_BLOCK_PENALTY;\n            }\n        }\n    }\n    // Rule 3: finder-like 1:1:3:1:1 with 4-light padding\n    let finderPenalty = 0;\n    for (let x = 0; x < width; x++)\n        finderPenalty += calculateRowFinderPenalty(matrix[x]);\n    for (let y = 0; y < height; y++)\n        finderPenalty += calculateColumnFinderPenalty(matrix, y, width);\n    // Rule 4: dark-module balance vs 50%\n    let darkCount = 0;\n    for (let x = 0; x < width; x++) {\n        const col = matrix[x];\n        for (let y = 0; y < height; y++)\n            if (col[y])\n                darkCount++;\n    }\n    const moduleCount = width * height;\n    const darkPercent = (darkCount * 100) / moduleCount;\n    const deviation = Math.abs(darkPercent - 50);\n    const balancePenalty = R4_BALANCE_STEP_POINTS * Math.floor(deviation / R4_BALANCE_STEP_PERCENT);\n    return runPenalty + blockPenalty + finderPenalty + balancePenalty;\n}\n// Selects best mask according to penalty, if no mask is provided\nfunction drawQRBest(ver, ecc, data, maskIdx) {\n    if (maskIdx === undefined) {\n        const bestMask = best();\n        for (let mask = 0; mask < PATTERNS.length; mask++)\n            bestMask.add(penalty(drawQR(ver, ecc, data, mask, true)), mask);\n        maskIdx = bestMask.get();\n    }\n    if (maskIdx === undefined)\n        throw new Error('Cannot find mask'); // Should never happen\n    return drawQR(ver, ecc, data, maskIdx);\n}\nfunction validateECC(ec) {\n    if (!ECMode.includes(ec))\n        throw new Error(`Invalid error correction mode=${ec}. Expected: ${ECMode}`);\n}\nfunction validateEncoding(enc) {\n    if (!Encoding.includes(enc))\n        throw new Error(`Encoding: invalid mode=${enc}. Expected: ${Encoding}`);\n    if (enc === 'kanji' || enc === 'eci')\n        throw new Error(`Encoding: ${enc} is not supported (yet?).`);\n}\nfunction validateMask(mask) {\n    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(mask) || !PATTERNS[mask])\n        throw new Error(`Invalid mask=${mask}. Expected number [0..7]`);\n}\nfunction encodeQR(text, output = 'raw', opts = {}) {\n    const ecc = opts.ecc !== undefined ? opts.ecc : 'medium';\n    validateECC(ecc);\n    const encoding = opts.encoding !== undefined ? opts.encoding : detectType(text);\n    validateEncoding(encoding);\n    if (opts.mask !== undefined)\n        validateMask(opts.mask);\n    let ver = opts.version;\n    let data, err = new Error('Unknown error');\n    if (ver !== undefined) {\n        validateVersion(ver);\n        data = encode(ver, ecc, text, encoding, opts.textEncoder);\n    }\n    else {\n        // If no version is provided, try to find smallest one which fits\n        // Currently just scans all version, can be significantly speedup if needed\n        for (let i = 1; i <= 40; i++) {\n            try {\n                data = encode(i, ecc, text, encoding, opts.textEncoder);\n                ver = i;\n                break;\n            }\n            catch (e) {\n                err = e;\n            }\n        }\n    }\n    if (!ver || !data)\n        throw err;\n    let res = drawQRBest(ver, ecc, data, opts.mask);\n    res.assertDrawn();\n    const border = opts.border === undefined ? 2 : opts.border;\n    if (!Number.isSafeInteger(border))\n        throw new Error(`invalid border type=${typeof border}`);\n    res = res.border(border, false); // Add border\n    if (opts.scale !== undefined)\n        res = res.scale(opts.scale); // Scale image\n    if (output === 'raw')\n        return res.data;\n    else if (output === 'ascii')\n        return res.toASCII();\n    else if (output === 'svg')\n        return res.toSVG(opts.optimize);\n    else if (output === 'gif')\n        return res.toGIF();\n    else if (output === 'term')\n        return res.toTerm();\n    else\n        throw new Error(`Unknown output: ${output}`);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encodeQR);\nconst utils = {\n    best,\n    bin,\n    drawTemplate,\n    fillArr,\n    info,\n    interleave,\n    validateVersion,\n    zigzag,\n};\n// Unsafe API utils, exported only for tests\nconst _tests = {\n    Bitmap,\n    info,\n    detectType,\n    encode,\n    drawQR,\n    penalty,\n    PATTERNS,\n};\n// Type tests\n// const o1 = qr('test', 'ascii');\n// const o2 = qr('test', 'raw');\n// const o3 = qr('test', 'gif');\n// const o4 = qr('test', 'svg');\n// const o5 = qr('test', 'term');\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcXJAMC41LjMvbm9kZV9tb2R1bGVzL3FyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxnREFBZ0Q7QUFDaEQsdUNBQXVDO0FBQ3ZDLHlDQUF5QztBQUN6QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDZDQUE2QyxFQUFFO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFNBQVM7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNB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O0FBQ0Esa0RBQWtELElBQUksY0FBYyxTQUFTO0FBQzdFO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDTyxpREFBaUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0EsaUVBQWUsUUFBUSxFQUFDO0FBQ2pCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BhbG0tYnVkZ2V0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL3FyQDAuNS4zL25vZGVfbW9kdWxlcy9xci9pbmRleC5qcz9kZWU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuQ29weXJpZ2h0IChjKSAyMDIzIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKVxuVGhlIGxpYnJhcnkgcGF1bG1pbGxyLXFyIGlzIGR1YWwtbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSAyLjAgT1IgTUlUIGxpY2Vuc2UuXG5Zb3UgY2FuIHNlbGVjdCBhIGxpY2Vuc2Ugb2YgeW91ciBjaG9pY2UuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vKipcbiAqIE1ldGhvZHMgZm9yIGVuY29kaW5nIChnZW5lcmF0aW5nKSBRUiBjb2RlIHBhdHRlcm5zLlxuICogQ2hlY2sgb3V0IGRlY29kZS50cyBmb3IgZGVjb2RpbmcgKHJlYWRpbmcpLlxuICogQG1vZHVsZVxuICogQGV4YW1wbGVcbmBgYGpzXG5pbXBvcnQgZW5jb2RlUVIgZnJvbSAncXInO1xuY29uc3QgdHh0ID0gJ0hlbGxvIHdvcmxkJztcbmNvbnN0IGFzY2lpID0gZW5jb2RlUVIodHh0LCAnYXNjaWknKTsgLy8gTm90IGFsbCBmb250cyBhcmUgc3VwcG9ydGVkXG5jb25zdCB0ZXJtaW5hbEZyaWVuZGx5ID0gZW5jb2RlUVIodHh0LCAndGVybScpOyAvLyAyeCBsYXJnZXIsIGFsbCBmb250cyBhcmUgT0tcbmNvbnN0IGdpZkJ5dGVzID0gZW5jb2RlUVIodHh0LCAnZ2lmJyk7IC8vIFVuY29tcHJlc3NlZCBHSUZcbmNvbnN0IHN2Z0VsZW1lbnQgPSBlbmNvZGVRUih0eHQsICdzdmcnKTsgLy8gU1ZHIHZlY3RvciBpbWFnZSBlbGVtZW50XG5jb25zdCBhcnJheSA9IGVuY29kZVFSKHR4dCwgJ3JhdycpOyAvLyAyZCBhcnJheSBmb3IgY2FudmFzIG9yIG90aGVyIGxpYnNcbi8vIGltcG9ydCBkZWNvZGVRUiBmcm9tICdxci9kZWNvZGUuanMnO1xuYGBgXG4gKi9cbmNvbnN0IFIxX1JVTl9MRU5HVEhfVEhSRVNIT0xEID0gNTtcbmNvbnN0IFIyX0JMT0NLX1BFTkFMVFkgPSAzO1xuY29uc3QgUjNfRklOREVSX1BBVFRFUk5fTEVOR1RIID0gMTE7XG5jb25zdCBSM19GSU5ERVJfUEVOQUxUWSA9IDQwO1xuY29uc3QgUjRfQkFMQU5DRV9TVEVQX1BFUkNFTlQgPSA1O1xuY29uc3QgUjRfQkFMQU5DRV9TVEVQX1BPSU5UUyA9IDEwO1xuLy8gV2UgZG8gbm90IHVzZSBuZXdsaW5lIGVzY2FwZSBjb2RlIGRpcmVjdGx5IGluIHN0cmluZ3MgYmVjYXVzZSBpdCdzIG5vdCBwYXJzZXItZnJpZW5kbHlcbmNvbnN0IGNoQ29kZXMgPSB7IG5ld2xpbmU6IDEwLCByZXNldDogMjcgfTtcbmZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnRlZ2VyIGV4cGVjdGVkOiAke259YCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVZlcnNpb24odmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2ZXIpIHx8IHZlciA8IDEgfHwgdmVyID4gNDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uPSR7dmVyfS4gRXhwZWN0ZWQgbnVtYmVyIFsxLi40MF1gKTtcbn1cbmZ1bmN0aW9uIGJpbihkZWMsIHBhZCkge1xuICAgIHJldHVybiBkZWMudG9TdHJpbmcoMikucGFkU3RhcnQocGFkLCAnMCcpO1xufVxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IDAgPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuZnVuY3Rpb24gZmlsbEFycihsZW5ndGgsIHZhbCkge1xuICAgIHJldHVybiBuZXcgQXJyYXkobGVuZ3RoKS5maWxsKHZhbCk7XG59XG4vKipcbiAqIEludGVybGVhdmVzIGJ5dGUgYmxvY2tzLlxuICogQHBhcmFtIGJsb2NrcyBbWzEsIDIsIDNdLCBbNCwgNSwgNl1dXG4gKiBAcmV0dXJucyBbMSwgNCwgMiwgNSwgMywgNl1cbiAqL1xuZnVuY3Rpb24gaW50ZXJsZWF2ZUJ5dGVzKGJsb2Nrcykge1xuICAgIGxldCBtYXhMZW4gPSAwO1xuICAgIGxldCB0b3RhbExlbiA9IDA7XG4gICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgbWF4TGVuID0gTWF0aC5tYXgobWF4TGVuLCBibG9jay5sZW5ndGgpO1xuICAgICAgICB0b3RhbExlbiArPSBibG9jay5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuKTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbjsgaSsrKSB7XG4gICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGJsb2NrLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXN1bHRbaWR4KytdID0gYmxvY2tbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIE9wdGltaXplIGZvciBtaW5pbWFsIHNjb3JlL3BlbmFsdHlcbmZ1bmN0aW9uIGJlc3QoKSB7XG4gICAgbGV0IGJlc3Q7XG4gICAgbGV0IGJlc3RTY29yZSA9IEluZmluaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZChzY29yZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChzY29yZSA+PSBiZXN0U2NvcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYmVzdCA9IHZhbHVlO1xuICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogKCkgPT4gYmVzdCxcbiAgICAgICAgc2NvcmU6ICgpID0+IGJlc3RTY29yZSxcbiAgICB9O1xufVxuLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1iYXNlL2Jsb2IvbWFpbi9pbmRleC50c1xuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXM6IChjaGFyKSA9PiBhbHBoYWJldC5pbmNsdWRlcyhjaGFyKSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIEJpdG1hcCB7XG4gICAgc3RhdGljIHNpemUoc2l6ZSwgbGltaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHNpemUgPSB7IGhlaWdodDogc2l6ZSwgd2lkdGg6IHNpemUgfTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzaXplLmhlaWdodCkgJiYgc2l6ZS5oZWlnaHQgIT09IEluZmluaXR5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgaGVpZ2h0PSR7c2l6ZS5oZWlnaHR9ICgke3R5cGVvZiBzaXplLmhlaWdodH0pYCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoc2l6ZS53aWR0aCkgJiYgc2l6ZS53aWR0aCAhPT0gSW5maW5pdHkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG1hcDogaW52YWxpZCB3aWR0aD0ke3NpemUud2lkdGh9ICgke3R5cGVvZiBzaXplLndpZHRofSlgKTtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIENsYW1wIGxlbmd0aCwgc28gaXQgd29uJ3Qgb3ZlcmZsb3csIGFsc28gYWxsb3dzIHRvIHVzZSBJbmZpbml0eSwgc28gd2UgZHJhdyB1bnRpbCBlbmRcbiAgICAgICAgICAgIHNpemUgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IE1hdGgubWluKHNpemUud2lkdGgsIGxpbWl0LndpZHRoKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IE1hdGgubWluKHNpemUuaGVpZ2h0LCBsaW1pdC5oZWlnaHQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcocykge1xuICAgICAgICAvLyBSZW1vdmUgbGluZWJyZWFrcyBvbiBzdGFydCBhbmQgZW5kLCBzbyB3ZSBkcmF3IGluIGBgIHNlY3Rpb25cbiAgICAgICAgcyA9IHMucmVwbGFjZSgvXlxcbisvZywgJycpLnJlcGxhY2UoL1xcbiskL2csICcnKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBzLnNwbGl0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2hDb2Rlcy5uZXdsaW5lKSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBBcnJheShoZWlnaHQpO1xuICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gbGluZS5zcGxpdCgnJykubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICdYJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnPycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXAuZnJvbVN0cmluZzogdW5rbm93biBzeW1ib2w9JHtpfWApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAod2lkdGggJiYgcm93Lmxlbmd0aCAhPT0gd2lkdGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXAuZnJvbVN0cmluZyBkaWZmZXJlbnQgcm93IHNpemVzOiB3aWR0aD0ke3dpZHRofSBjdXI9JHtyb3cubGVuZ3RofWApO1xuICAgICAgICAgICAgd2lkdGggPSByb3cubGVuZ3RoO1xuICAgICAgICAgICAgZGF0YS5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aWR0aClcbiAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRtYXAoeyBoZWlnaHQsIHdpZHRoIH0sIGRhdGEpO1xuICAgIH1cbiAgICBkYXRhO1xuICAgIGhlaWdodDtcbiAgICB3aWR0aDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gQml0bWFwLnNpemUoc2l6ZSk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgQXJyYXkuZnJvbSh7IGxlbmd0aDogaGVpZ2h0IH0sICgpID0+IGZpbGxBcnIod2lkdGgsIHVuZGVmaW5lZCkpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgICBwb2ludChwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbcC55XVtwLnhdO1xuICAgIH1cbiAgICBpc0luc2lkZShwKSB7XG4gICAgICAgIHJldHVybiAwIDw9IHAueCAmJiBwLnggPCB0aGlzLndpZHRoICYmIDAgPD0gcC55ICYmIHAueSA8IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICBzaXplKG9mZnNldCkge1xuICAgICAgICBpZiAoIW9mZnNldClcbiAgICAgICAgICAgIHJldHVybiB7IGhlaWdodDogdGhpcy5oZWlnaHQsIHdpZHRoOiB0aGlzLndpZHRoIH07XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy54eShvZmZzZXQpO1xuICAgICAgICByZXR1cm4geyBoZWlnaHQ6IHRoaXMuaGVpZ2h0IC0geSwgd2lkdGg6IHRoaXMud2lkdGggLSB4IH07XG4gICAgfVxuICAgIHh5KGMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGMgPSB7IHg6IGMsIHk6IGMgfTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjLngpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgeD0ke2MueH1gKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihjLnkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgeT0ke2MueX1gKTtcbiAgICAgICAgLy8gRG8gbW9kdWxvLCBzbyB3ZSBjYW4gdXNlIG5lZ2F0aXZlIHBvc2l0aW9uc1xuICAgICAgICBjLnggPSBtb2QoYy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgYy55ID0gbW9kKGMueSwgdGhpcy5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgLy8gQmFzaWNhbGx5IGV2ZXJ5IG9wZXJhdGlvbiBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgcmVjdFxuICAgIHJlY3QoYywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnh5KGMpO1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IEJpdG1hcC5zaXplKHNpemUsIHRoaXMuc2l6ZSh7IHgsIHkgfSkpO1xuICAgICAgICBmb3IgKGxldCB5UG9zID0gMDsgeVBvcyA8IGhlaWdodDsgeVBvcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4UG9zID0gMDsgeFBvcyA8IHdpZHRoOyB4UG9zKyspIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSB1c2UgZ2l2ZSBmdW5jdGlvbiByZWxhdGl2ZSBjb29yZGluYXRlcyBpbnNpZGUgYm94XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3kgKyB5UG9zXVt4ICsgeFBvc10gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWUoeyB4OiB4UG9zLCB5OiB5UG9zIH0sIHRoaXMuZGF0YVt5ICsgeVBvc11beCArIHhQb3NdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyByZWN0YW5ndWxhciBwYXJ0IG9mIGJpdG1hcFxuICAgIHJlY3RSZWFkKGMsIHNpemUsIGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgc2l6ZSwgKGMsIGN1cikgPT4ge1xuICAgICAgICAgICAgZm4oYywgY3VyKTtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBIb3Jpem9udGFsICYgdmVydGljYWwgbGluZXNcbiAgICBoTGluZShjLCBsZW4sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgeyB3aWR0aDogbGVuLCBoZWlnaHQ6IDEgfSwgdmFsdWUpO1xuICAgIH1cbiAgICB2TGluZShjLCBsZW4sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgeyB3aWR0aDogMSwgaGVpZ2h0OiBsZW4gfSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBhZGQgYm9yZGVyXG4gICAgYm9yZGVyKGJvcmRlciA9IDIsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMiAqIGJvcmRlcjtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICsgMiAqIGJvcmRlcjtcbiAgICAgICAgY29uc3QgdiA9IGZpbGxBcnIoYm9yZGVyLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGggPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBib3JkZXIgfSwgKCkgPT4gZmlsbEFycih3aWR0aCwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRtYXAoeyBoZWlnaHQsIHdpZHRoIH0sIFsuLi5oLCAuLi50aGlzLmRhdGEubWFwKChpKSA9PiBbLi4udiwgLi4uaSwgLi4udl0pLCAuLi5oXSk7XG4gICAgfVxuICAgIC8vIEVtYmVkIGFub3RoZXIgYml0bWFwIG9uIGNvb3JkaW5hdGVzXG4gICAgZW1iZWQoYywgYm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdChjLCBibS5zaXplKCksICh7IHgsIHkgfSkgPT4gYm0uZGF0YVt5XVt4XSk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgcmVjdGFuZ3VsYXIgcGFydCBvZiBiaXRtYXBcbiAgICByZWN0U2xpY2UoYywgc2l6ZSA9IHRoaXMuc2l6ZSgpKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBuZXcgQml0bWFwKEJpdG1hcC5zaXplKHNpemUsIHRoaXMuc2l6ZSh0aGlzLnh5KGMpKSkpO1xuICAgICAgICB0aGlzLnJlY3QoYywgc2l6ZSwgKHsgeCwgeSB9LCBjdXIpID0+IChyZWN0LmRhdGFbeV1beF0gPSBjdXIpKTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIC8vIENoYW5nZSBzaGFwZSwgcmVwbGFjZSByb3dzIHdpdGggY29sdW1ucyAoZGF0YVt5XVt4XSAtPiBkYXRhW3hdW3ldKVxuICAgIGludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEJpdG1hcCh7IGhlaWdodDogd2lkdGgsIHdpZHRoOiBoZWlnaHQgfSk7XG4gICAgICAgIHJldHVybiByZXMucmVjdCh7IHg6IDAsIHk6IDAgfSwgSW5maW5pdHksICh7IHgsIHkgfSkgPT4gdGhpcy5kYXRhW3hdW3ldKTtcbiAgICB9XG4gICAgLy8gRWFjaCBwaXhlbCBzaXplIGlzIG11bHRpcGxpZWQgYnkgZmFjdG9yXG4gICAgc2NhbGUoZmFjdG9yKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZmFjdG9yKSB8fCBmYWN0b3IgPiAxMDI0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNjYWxlIGZhY3RvcjogJHtmYWN0b3J9YCk7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEJpdG1hcCh7IGhlaWdodDogZmFjdG9yICogaGVpZ2h0LCB3aWR0aDogZmFjdG9yICogd2lkdGggfSk7XG4gICAgICAgIHJldHVybiByZXMucmVjdCh7IHg6IDAsIHk6IDAgfSwgSW5maW5pdHksICh7IHgsIHkgfSkgPT4gdGhpcy5kYXRhW01hdGguZmxvb3IoeSAvIGZhY3RvcildW01hdGguZmxvb3IoeCAvIGZhY3RvcildKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBCaXRtYXAodGhpcy5zaXplKCkpO1xuICAgICAgICByZXR1cm4gcmVzLnJlY3QoeyB4OiAwLCB5OiAwIH0sIHRoaXMuc2l6ZSgpLCAoeyB4LCB5IH0pID0+IHRoaXMuZGF0YVt5XVt4XSk7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIG5vIHVuZGVmaW5lZCB2YWx1ZXMgbGVmdFxuICAgIGFzc2VydERyYXduKCkge1xuICAgICAgICB0aGlzLnJlY3RSZWFkKDAsIEluZmluaXR5LCAoXywgY3VyKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciB0eXBlPSR7dHlwZW9mIGN1cn1gKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFNpbXBsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhXG4gICAgICAgICAgICAubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gKGogPT09IHVuZGVmaW5lZCA/ICc/JyA6IGogPyAnWCcgOiAnICcpKS5qb2luKCcnKSlcbiAgICAgICAgICAgIC5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hDb2Rlcy5uZXdsaW5lKSk7XG4gICAgfVxuICAgIHRvQVNDSUkoKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCwgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAvLyBUZXJtaW5hbCBjaGFyYWN0ZXIgaGVpZ2h0IGlzIHgyIG9mIGNoYXJhY3RlciB3aWR0aCwgc28gd2UgcHJvY2VzcyB0d28gcm93cyBvZiBiaXRtYXBcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBvbmUgcm93IG9mIEFTQ0lJXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YVt5XVt4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmQgPSB5ICsgMSA+PSBoZWlnaHQgPyB0cnVlIDogZGF0YVt5ICsgMV1beF07IC8vIGlmIGxhc3Qgcm93IG91dHNpZGUgYml0bWFwLCBtYWtlIGl0IGJsYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCAmJiAhc2Vjb25kKVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ+KWiCc7IC8vIGJvdGggcm93cyB3aGl0ZSAoZW1wdHkpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZpcnN0ICYmIHNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICfiloAnOyAvLyB0b3Agcm93IHdoaXRlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgJiYgIXNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICfiloQnOyAvLyBkb3duIHJvdyB3aGl0ZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ICYmIHNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJzsgLy8gYm90aCByb3dzIGJsYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaENvZGVzLm5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRvVGVybSgpIHtcbiAgICAgICAgY29uc3QgY2MgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoQ29kZXMucmVzZXQpO1xuICAgICAgICBjb25zdCByZXNldCA9IGNjICsgJ1swbSc7XG4gICAgICAgIGNvbnN0IHdoaXRlQkcgPSBjYyArICdbMTs0N20gICcgKyByZXNldDtcbiAgICAgICAgY29uc3QgZGFya0JHID0gY2MgKyBgWzQwbSAgYCArIHJlc2V0O1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhXG4gICAgICAgICAgICAubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gKGogPyBkYXJrQkcgOiB3aGl0ZUJHKSkuam9pbignJykpXG4gICAgICAgICAgICAuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKGNoQ29kZXMubmV3bGluZSkpO1xuICAgIH1cbiAgICB0b1NWRyhvcHRpbWl6ZSA9IHRydWUpIHtcbiAgICAgICAgbGV0IG91dCA9IGA8c3ZnIHZpZXdCb3g9XCIwIDAgJHt0aGlzLndpZHRofSAke3RoaXMuaGVpZ2h0fVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5gO1xuICAgICAgICAvLyBDb25zdHJ1Y3Qgb3B0aW1pemVkIFNWRyBwYXRoIGRhdGEuXG4gICAgICAgIGxldCBwYXRoRGF0YSA9ICcnO1xuICAgICAgICBsZXQgcHJldlBvaW50O1xuICAgICAgICB0aGlzLnJlY3RSZWFkKDAsIEluZmluaXR5LCAocG9pbnQsIHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF2YWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICAgICAgICAgIGlmICghb3B0aW1pemUpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gYDxyZWN0IHg9XCIke3h9XCIgeT1cIiR7eX1cIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgLz5gO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9SZWZlcmVuY2UvQXR0cmlidXRlL2QjcGF0aF9jb21tYW5kc1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaG9ydGVzdCB3YXkgdG8gcmVwcmVzZW50IHRoZSBpbml0aWFsIGN1cnNvciBtb3ZlbWVudC5cbiAgICAgICAgICAgIC8vIE0gLSBNb3ZlIGN1cnNvciAod2l0aG91dCBkcmF3aW5nKSB0byBhYnNvbHV0ZSBjb29yZGluYXRlIHBhaXIuXG4gICAgICAgICAgICBsZXQgbSA9IGBNJHt4fSAke3l9YDtcbiAgICAgICAgICAgIC8vIE9ubHkgYWxsb3cgdXNpbmcgdGhlIHJlbGF0aXZlIGN1cnNvciBtb3ZlIGNvbW1hbmQgaWYgcHJldmlvdXMgcG9pbnRzXG4gICAgICAgICAgICAvLyB3ZXJlIGRyYXduLlxuICAgICAgICAgICAgaWYgKHByZXZQb2ludCkge1xuICAgICAgICAgICAgICAgIC8vIG0gLSBNb3ZlIGN1cnNvciAod2l0aG91dCBkcmF3aW5nKSB0byByZWxhdGl2ZSBjb29yZGluYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVsTSA9IGBtJHt4IC0gcHJldlBvaW50Lnh9ICR7eSAtIHByZXZQb2ludC55fWA7XG4gICAgICAgICAgICAgICAgaWYgKHJlbE0ubGVuZ3RoIDw9IG0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtID0gcmVsTTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgc2hvcnRlc3Qgd2F5IHRvIHJlcHJlc2VudCB0aGUgY2VsbCdzIGJvdHRvbSBsaW5lIGRyYXcuXG4gICAgICAgICAgICAvLyBIIC0gRHJhdyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIGFic29sdXRlIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIC8vIGggLSBEcmF3IGxpbmUgZnJvbSBjdXJzb3IgcG9zaXRpb24gdG8gcmVsYXRpdmUgeCBjb29yZGluYXRlLlxuICAgICAgICAgICAgY29uc3QgYkggPSB4IDwgMTAgPyBgSCR7eH1gIDogJ2gtMSc7XG4gICAgICAgICAgICAvLyB2IC0gRHJhdyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIHJlbGF0aXZlIHkgY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIC8vIFogLSBDbG9zZSBwYXRoIChkcmF3cyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIE0gY29vcmRpbmF0ZSkuXG4gICAgICAgICAgICBwYXRoRGF0YSArPSBgJHttfWgxdjEke2JIfVpgO1xuICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW1pemUpXG4gICAgICAgICAgICBvdXQgKz0gYDxwYXRoIGQ9XCIke3BhdGhEYXRhfVwiLz5gO1xuICAgICAgICBvdXQgKz0gYDwvc3ZnPmA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRvR0lGKCkge1xuICAgICAgICAvLyBOT1RFOiBTbWFsbCwgYnV0IGluZWZmaWNpZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAvLyBVc2VzIDEgYnl0ZSBwZXIgcGl4ZWwuXG4gICAgICAgIGNvbnN0IHUxNmxlID0gKGkpID0+IFtpICYgMHhmZiwgKGkgPj4+IDgpICYgMHhmZl07XG4gICAgICAgIGNvbnN0IGRpbXMgPSBbLi4udTE2bGUodGhpcy53aWR0aCksIC4uLnUxNmxlKHRoaXMuaGVpZ2h0KV07XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5yZWN0UmVhZCgwLCBJbmZpbml0eSwgKF8sIGN1cikgPT4gZGF0YS5wdXNoKCsoY3VyID09PSB0cnVlKSkpO1xuICAgICAgICBjb25zdCBOID0gMTI2OyAvLyBCbG9jayBzaXplXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjb25zdCBieXRlcyA9IFtcbiAgICAgICAgICAgIDB4NDcsIDB4NDksIDB4NDYsIDB4MzgsIDB4MzcsIDB4NjEsIC4uLmRpbXMsIDB4ZjYsIDB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gICAgICAgICAgICAuLi5maWxsQXJyKDMgKiAxMjcsIDB4MDApLCAweDJjLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAuLi5kaW1zLCAweDAwLCAweDA3XG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGZ1bGxDaHVua3MgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gTik7XG4gICAgICAgIC8vIEZ1bGwgYmxvY2tzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKVxuICAgICAgICAgICAgYnl0ZXMucHVzaChOICsgMSwgMHg4MCwgLi4uZGF0YS5zbGljZShOICogaSwgTiAqIChpICsgMSkpLm1hcCgoaSkgPT4gK2kpKTtcbiAgICAgICAgLy8gUmVtYWluaW5nIGJ5dGVzXG4gICAgICAgIGJ5dGVzLnB1c2goKGRhdGEubGVuZ3RoICUgTikgKyAxLCAweDgwLCAuLi5kYXRhLnNsaWNlKGZ1bGxDaHVua3MgKiBOKS5tYXAoKGkpID0+ICtpKSk7XG4gICAgICAgIGJ5dGVzLnB1c2goMHgwMSwgMHg4MSwgMHgwMCwgMHgzYik7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgfVxuICAgIHRvSW1hZ2UoaXNSR0IgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IHRoaXMuc2l6ZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaGVpZ2h0ICogd2lkdGggKiAoaXNSR0IgPyAzIDogNCkpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gISF0aGlzLmRhdGFbeV1beF0gPyAwIDogMjU1O1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghaXNSR0IpXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IDI1NTsgLy8gYWxwaGEgY2hhbm5lbFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGgsIGRhdGEgfTtcbiAgICB9XG59XG4vLyBFbmQgb2YgdXRpbHNcbi8vIFJ1bnRpbWUgdHlwZS1jaGVja2luZ1xuLyoqIEVycm9yIGNvcnJlY3Rpb24gbW9kZS4gbG93OiA3JSwgbWVkaXVtOiAxNSUsIHF1YXJ0aWxlOiAyNSUsIGhpZ2g6IDMwJSAqL1xuZXhwb3J0IGNvbnN0IEVDTW9kZSA9IFsnbG93JywgJ21lZGl1bScsICdxdWFydGlsZScsICdoaWdoJ107XG4vKiogUVIgQ29kZSBlbmNvZGluZyAqL1xuZXhwb3J0IGNvbnN0IEVuY29kaW5nID0gWydudW1lcmljJywgJ2FscGhhbnVtZXJpYycsICdieXRlJywgJ2thbmppJywgJ2VjaSddO1xuLy8gVmFyaW91cyBjb25zdGFudHMgJiB0YWJsZXNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQllURVMgPSBbXG4gICAgLy8gMSwgIDIsICAzLCAgIDQsICAgNSwgICA2LCAgIDcsICAgOCwgICA5LCAgMTAsICAxMSwgIDEyLCAgMTMsICAxNCwgIDE1LCAgMTYsICAxNywgIDE4LCAgMTksICAgMjAsXG4gICAgMjYsIDQ0LCA3MCwgMTAwLCAxMzQsIDE3MiwgMTk2LCAyNDIsIDI5MiwgMzQ2LCA0MDQsIDQ2NiwgNTMyLCA1ODEsIDY1NSwgNzMzLCA4MTUsIDkwMSwgOTkxLCAxMDg1LFxuICAgIC8vICAyMSwgICAyMiwgICAyMywgICAyNCwgICAyNSwgICAyNiwgICAyNywgICAyOCwgICAyOSwgICAzMCwgICAzMSwgICAzMiwgICAzMywgICAzNCwgICAzNSwgICAzNiwgICAzNywgICAzOCwgICAzOSwgICA0MFxuICAgIDExNTYsIDEyNTgsIDEzNjQsIDE0NzQsIDE1ODgsIDE3MDYsIDE4MjgsIDE5MjEsIDIwNTEsIDIxODUsIDIzMjMsIDI0NjUsIDI2MTEsIDI3NjEsIDI4NzYsIDMwMzQsIDMxOTYsIDMzNjIsIDM1MzIsIDM3MDYsXG5dO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBXT1JEU19QRVJfQkxPQ0sgPSB7XG4gICAgLy8gVmVyc2lvbiAxLCAgMiwgIDMsICA0LCAgNSwgIDYsICA3LCAgOCwgIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwXG4gICAgbG93OiBbNywgMTAsIDE1LCAyMCwgMjYsIDE4LCAyMCwgMjQsIDMwLCAxOCwgMjAsIDI0LCAyNiwgMzAsIDIyLCAyNCwgMjgsIDMwLCAyOCwgMjgsIDI4LCAyOCwgMzAsIDMwLCAyNiwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgbWVkaXVtOiBbMTAsIDE2LCAyNiwgMTgsIDI0LCAxNiwgMTgsIDIyLCAyMiwgMjYsIDMwLCAyMiwgMjIsIDI0LCAyNCwgMjgsIDI4LCAyNiwgMjYsIDI2LCAyNiwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjhdLFxuICAgIHF1YXJ0aWxlOiBbMTMsIDIyLCAxOCwgMjYsIDE4LCAyNCwgMTgsIDIyLCAyMCwgMjQsIDI4LCAyNiwgMjQsIDIwLCAzMCwgMjQsIDI4LCAyOCwgMjYsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzBdLFxuICAgIGhpZ2g6IFsxNywgMjgsIDIyLCAxNiwgMjIsIDI4LCAyNiwgMjYsIDI0LCAyOCwgMjQsIDI4LCAyMiwgMjQsIDI0LCAzMCwgMjgsIDI4LCAyNiwgMjgsIDMwLCAyNCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBFQ0NfQkxPQ0tTID0ge1xuICAgIC8vIFZlcnNpb24gICAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsIDI1LCAyNiwgMjcsIDI4LCAyOSwgMzAsIDMxLCAzMiwgMzMsIDM0LCAzNSwgMzYsIDM3LCAzOCwgMzksIDQwXG4gICAgbG93OiBbMSwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgNCwgNCwgNCwgNCwgNCwgNiwgNiwgNiwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAxOSwgMjAsIDIxLCAyMiwgMjQsIDI1XSxcbiAgICBtZWRpdW06IFsxLCAxLCAxLCAyLCAyLCA0LCA0LCA0LCA1LCA1LCA1LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMywgMTQsIDE2LCAxNywgMTcsIDE4LCAyMCwgMjEsIDIzLCAyNSwgMjYsIDI4LCAyOSwgMzEsIDMzLCAzNSwgMzcsIDM4LCA0MCwgNDMsIDQ1LCA0NywgNDldLFxuICAgIHF1YXJ0aWxlOiBbMSwgMSwgMiwgMiwgNCwgNCwgNiwgNiwgOCwgOCwgOCwgMTAsIDEyLCAxNiwgMTIsIDE3LCAxNiwgMTgsIDIxLCAyMCwgMjMsIDIzLCAyNSwgMjcsIDI5LCAzNCwgMzQsIDM1LCAzOCwgNDAsIDQzLCA0NSwgNDgsIDUxLCA1MywgNTYsIDU5LCA2MiwgNjUsIDY4XSxcbiAgICBoaWdoOiBbMSwgMSwgMiwgNCwgNCwgNCwgNSwgNiwgOCwgOCwgMTEsIDExLCAxNiwgMTYsIDE4LCAxNiwgMTksIDIxLCAyNSwgMjUsIDI1LCAzNCwgMzAsIDMyLCAzNSwgMzcsIDQwLCA0MiwgNDUsIDQ4LCA1MSwgNTQsIDU3LCA2MCwgNjMsIDY2LCA3MCwgNzQsIDc3LCA4MV0sXG59O1xuY29uc3QgaW5mbyA9IHtcbiAgICBzaXplOiB7XG4gICAgICAgIGVuY29kZTogKHZlcikgPT4gMjEgKyA0ICogKHZlciAtIDEpLCAvLyB2ZXIxID0gMjEsIHZlcjQwPTE3NyBibG9ja3NcbiAgICAgICAgZGVjb2RlOiAoc2l6ZSkgPT4gKHNpemUgLSAxNykgLyA0LFxuICAgIH0sXG4gICAgc2l6ZVR5cGU6ICh2ZXIpID0+IE1hdGguZmxvb3IoKHZlciArIDcpIC8gMTcpLFxuICAgIC8vIEJhc2VkIG9uIGh0dHBzOi8vY29kZXJldmlldy5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzQ5MjUvYWxnb3JpdGhtLXRvLWdlbmVyYXRlLXRoaXMtYWxpZ25tZW50LXBhdHRlcm4tbG9jYXRpb25zLXRhYmxlLWZvci1xci1jb2Rlc1xuICAgIGFsaWdubWVudFBhdHRlcm5zKHZlcikge1xuICAgICAgICBpZiAodmVyID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBmaXJzdCA9IDY7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBpbmZvLnNpemUuZW5jb2RlKHZlcikgLSBmaXJzdCAtIDE7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gbGFzdCAtIGZpcnN0O1xuICAgICAgICBjb25zdCBjb3VudCA9IE1hdGguY2VpbChkaXN0YW5jZSAvIDI4KTtcbiAgICAgICAgbGV0IGludGVydmFsID0gTWF0aC5mbG9vcihkaXN0YW5jZSAvIGNvdW50KTtcbiAgICAgICAgaWYgKGludGVydmFsICUgMilcbiAgICAgICAgICAgIGludGVydmFsICs9IDE7XG4gICAgICAgIGVsc2UgaWYgKChkaXN0YW5jZSAlIGNvdW50KSAqIDIgPj0gY291bnQpXG4gICAgICAgICAgICBpbnRlcnZhbCArPSAyO1xuICAgICAgICBjb25zdCByZXMgPSBbZmlyc3RdO1xuICAgICAgICBmb3IgKGxldCBtID0gMTsgbSA8IGNvdW50OyBtKyspXG4gICAgICAgICAgICByZXMucHVzaChsYXN0IC0gKGNvdW50IC0gbSkgKiBpbnRlcnZhbCk7XG4gICAgICAgIHJlcy5wdXNoKGxhc3QpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgRUNDb2RlOiB7XG4gICAgICAgIGxvdzogMGIwMSxcbiAgICAgICAgbWVkaXVtOiAwYjAwLFxuICAgICAgICBxdWFydGlsZTogMGIxMSxcbiAgICAgICAgaGlnaDogMGIxMCxcbiAgICB9LFxuICAgIGZvcm1hdE1hc2s6IDBiMTAxMDEwMDAwMDEwMDEwLFxuICAgIGZvcm1hdEJpdHMoZWNjLCBtYXNrSWR4KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoaW5mby5FQ0NvZGVbZWNjXSA8PCAzKSB8IG1hc2tJZHg7XG4gICAgICAgIGxldCBkID0gZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgZCA9IChkIDw8IDEpIF4gKChkID4+IDkpICogMGIxMDEwMDExMDExMSk7XG4gICAgICAgIHJldHVybiAoKGRhdGEgPDwgMTApIHwgZCkgXiBpbmZvLmZvcm1hdE1hc2s7XG4gICAgfSxcbiAgICB2ZXJzaW9uQml0cyh2ZXIpIHtcbiAgICAgICAgbGV0IGQgPSB2ZXI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgICAgIGQgPSAoZCA8PCAxKSBeICgoZCA+PiAxMSkgKiAwYjExMTExMDAxMDAxMDEpO1xuICAgICAgICByZXR1cm4gKHZlciA8PCAxMikgfCBkO1xuICAgIH0sXG4gICAgYWxwaGFiZXQ6IHtcbiAgICAgICAgbnVtZXJpYzogYWxwaGFiZXQoJzAxMjM0NTY3ODknKSxcbiAgICAgICAgYWxwaGFudW1lcmM6IGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzonKSxcbiAgICB9LCAvLyBhcyBSZWNvcmQ8RW5jb2RpbmdUeXBlLCBSZXR1cm5UeXBlPHR5cGVvZiBhbHBoYWJldD4+LFxuICAgIGxlbmd0aEJpdHModmVyLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlID0ge1xuICAgICAgICAgICAgbnVtZXJpYzogWzEwLCAxMiwgMTRdLFxuICAgICAgICAgICAgYWxwaGFudW1lcmljOiBbOSwgMTEsIDEzXSxcbiAgICAgICAgICAgIGJ5dGU6IFs4LCAxNiwgMTZdLFxuICAgICAgICAgICAga2Fuamk6IFs4LCAxMCwgMTJdLFxuICAgICAgICAgICAgZWNpOiBbMCwgMCwgMF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0YWJsZVt0eXBlXVtpbmZvLnNpemVUeXBlKHZlcildO1xuICAgIH0sXG4gICAgbW9kZUJpdHM6IHtcbiAgICAgICAgbnVtZXJpYzogJzAwMDEnLFxuICAgICAgICBhbHBoYW51bWVyaWM6ICcwMDEwJyxcbiAgICAgICAgYnl0ZTogJzAxMDAnLFxuICAgICAgICBrYW5qaTogJzEwMDAnLFxuICAgICAgICBlY2k6ICcwMTExJyxcbiAgICB9LFxuICAgIGNhcGFjaXR5KHZlciwgZWNjKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQllURVNbdmVyIC0gMV07XG4gICAgICAgIGNvbnN0IHdvcmRzID0gV09SRFNfUEVSX0JMT0NLW2VjY11bdmVyIC0gMV07XG4gICAgICAgIGNvbnN0IG51bUJsb2NrcyA9IEVDQ19CTE9DS1NbZWNjXVt2ZXIgLSAxXTtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBNYXRoLmZsb29yKGJ5dGVzIC8gbnVtQmxvY2tzKSAtIHdvcmRzO1xuICAgICAgICBjb25zdCBzaG9ydEJsb2NrcyA9IG51bUJsb2NrcyAtIChieXRlcyAlIG51bUJsb2Nrcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3b3JkcyxcbiAgICAgICAgICAgIG51bUJsb2NrcyxcbiAgICAgICAgICAgIHNob3J0QmxvY2tzLFxuICAgICAgICAgICAgYmxvY2tMZW4sXG4gICAgICAgICAgICBjYXBhY2l0eTogKGJ5dGVzIC0gd29yZHMgKiBudW1CbG9ja3MpICogOCxcbiAgICAgICAgICAgIHRvdGFsOiAod29yZHMgKyBibG9ja0xlbikgKiBudW1CbG9ja3MgKyBudW1CbG9ja3MgLSBzaG9ydEJsb2NrcyxcbiAgICAgICAgfTtcbiAgICB9LFxufTtcbmNvbnN0IFBBVFRFUk5TID0gW1xuICAgICh4LCB5KSA9PiAoeCArIHkpICUgMiA9PSAwLFxuICAgIChfeCwgeSkgPT4geSAlIDIgPT0gMCxcbiAgICAoeCwgX3kpID0+IHggJSAzID09IDAsXG4gICAgKHgsIHkpID0+ICh4ICsgeSkgJSAzID09IDAsXG4gICAgKHgsIHkpID0+IChNYXRoLmZsb29yKHkgLyAyKSArIE1hdGguZmxvb3IoeCAvIDMpKSAlIDIgPT0gMCxcbiAgICAoeCwgeSkgPT4gKCh4ICogeSkgJSAyKSArICgoeCAqIHkpICUgMykgPT0gMCxcbiAgICAoeCwgeSkgPT4gKCgoeCAqIHkpICUgMikgKyAoKHggKiB5KSAlIDMpKSAlIDIgPT0gMCxcbiAgICAoeCwgeSkgPT4gKCgoeCArIHkpICUgMikgKyAoKHggKiB5KSAlIDMpKSAlIDIgPT0gMCxcbl07XG4vLyBHYWxvaXMgZmllbGQgJiYgcmVlZC1zb2xvbW9uIGVuY29kaW5nXG5jb25zdCBHRiA9IHtcbiAgICB0YWJsZXM6ICgocF9wb2x5KSA9PiB7XG4gICAgICAgIGNvbnN0IGV4cCA9IGZpbGxBcnIoMjU2LCAwKTtcbiAgICAgICAgY29uc3QgbG9nID0gZmlsbEFycigyNTYsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgeCA9IDE7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgZXhwW2ldID0geDtcbiAgICAgICAgICAgIGxvZ1t4XSA9IGk7XG4gICAgICAgICAgICB4IDw8PSAxO1xuICAgICAgICAgICAgaWYgKHggJiAweDEwMClcbiAgICAgICAgICAgICAgICB4IF49IHBfcG9seTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBleHAsIGxvZyB9O1xuICAgIH0pKDB4MTFkKSxcbiAgICBleHA6ICh4KSA9PiBHRi50YWJsZXMuZXhwW3hdLFxuICAgIGxvZyh4KSB7XG4gICAgICAgIGlmICh4ID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHRi5sb2c6IGludmFsaWQgYXJnPSR7eH1gKTtcbiAgICAgICAgcmV0dXJuIEdGLnRhYmxlcy5sb2dbeF0gJSAyNTU7XG4gICAgfSxcbiAgICBtdWwoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0gMCB8fCB5ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHRi50YWJsZXMuZXhwWyhHRi50YWJsZXMubG9nW3hdICsgR0YudGFibGVzLmxvZ1t5XSkgJSAyNTVdO1xuICAgIH0sXG4gICAgYWRkOiAoeCwgeSkgPT4geCBeIHksXG4gICAgcG93OiAoeCwgZSkgPT4gR0YudGFibGVzLmV4cFsoR0YudGFibGVzLmxvZ1t4XSAqIGUpICUgMjU1XSxcbiAgICBpbnYoeCkge1xuICAgICAgICBpZiAoeCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR0YuaW52ZXJzZTogaW52YWxpZCBhcmc9JHt4fWApO1xuICAgICAgICByZXR1cm4gR0YudGFibGVzLmV4cFsyNTUgLSBHRi50YWJsZXMubG9nW3hdXTtcbiAgICB9LFxuICAgIHBvbHlub21pYWwocG9seSkge1xuICAgICAgICBpZiAocG9seS5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR0YucG9seW1vbWlhbDogaW52YWxpZCBsZW5ndGgnKTtcbiAgICAgICAgaWYgKHBvbHlbMF0gIT09IDApXG4gICAgICAgICAgICByZXR1cm4gcG9seTtcbiAgICAgICAgLy8gU3RyaXAgbGVhZGluZyB6ZXJvc1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgcG9seS5sZW5ndGggLSAxICYmIHBvbHlbaV0gPT0gMDsgaSsrKVxuICAgICAgICAgICAgO1xuICAgICAgICByZXR1cm4gcG9seS5zbGljZShpKTtcbiAgICB9LFxuICAgIG1vbm9taWFsKGRlZ3JlZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgaWYgKGRlZ3JlZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdGLm1vbm9taWFsOiBpbnZhbGlkIGRlZ3JlZT0ke2RlZ3JlZX1gKTtcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICBsZXQgY29lZmZpY2llbnRzID0gZmlsbEFycihkZWdyZWUgKyAxLCAwKTtcbiAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7XG4gICAgICAgIHJldHVybiBHRi5wb2x5bm9taWFsKGNvZWZmaWNpZW50cyk7XG4gICAgfSxcbiAgICBkZWdyZWU6IChhKSA9PiBhLmxlbmd0aCAtIDEsXG4gICAgY29lZmZpY2llbnQ6IChhLCBkZWdyZWUpID0+IGFbR0YuZGVncmVlKGEpIC0gZGVncmVlXSxcbiAgICBtdWxQb2x5KGEsIGIpIHtcbiAgICAgICAgaWYgKGFbMF0gPT09IDAgfHwgYlswXSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbGxBcnIoYS5sZW5ndGggKyBiLmxlbmd0aCAtIDEsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc1tpICsgal0gPSBHRi5hZGQocmVzW2kgKyBqXSwgR0YubXVsKGFbaV0sIGJbal0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChyZXMpO1xuICAgIH0sXG4gICAgbXVsUG9seVNjYWxhcihhLCBzY2FsYXIpIHtcbiAgICAgICAgaWYgKHNjYWxhciA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgaWYgKHNjYWxhciA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbGxBcnIoYS5sZW5ndGgsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXNbaV0gPSBHRi5tdWwoYVtpXSwgc2NhbGFyKTtcbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwocmVzKTtcbiAgICB9LFxuICAgIG11bFBvbHlNb25vbWlhbChhLCBkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGlmIChkZWdyZWUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHRi5tdWxQb2x5TW9ub21pYWw6IGludmFsaWQgZGVncmVlJyk7XG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgY29uc3QgcmVzID0gZmlsbEFycihhLmxlbmd0aCArIGRlZ3JlZSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc1tpXSA9IEdGLm11bChhW2ldLCBjb2VmZmljaWVudCk7XG4gICAgICAgIHJldHVybiBHRi5wb2x5bm9taWFsKHJlcyk7XG4gICAgfSxcbiAgICBhZGRQb2x5KGEsIGIpIHtcbiAgICAgICAgaWYgKGFbMF0gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgaWYgKGJbMF0gPT09IDApXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgbGV0IHNtYWxsZXIgPSBhO1xuICAgICAgICBsZXQgbGFyZ2VyID0gYjtcbiAgICAgICAgaWYgKHNtYWxsZXIubGVuZ3RoID4gbGFyZ2VyLmxlbmd0aClcbiAgICAgICAgICAgIFtzbWFsbGVyLCBsYXJnZXJdID0gW2xhcmdlciwgc21hbGxlcl07XG4gICAgICAgIGxldCBzdW1EaWZmID0gZmlsbEFycihsYXJnZXIubGVuZ3RoLCAwKTtcbiAgICAgICAgbGV0IGxlbmd0aERpZmYgPSBsYXJnZXIubGVuZ3RoIC0gc21hbGxlci5sZW5ndGg7XG4gICAgICAgIGxldCBzID0gbGFyZ2VyLnNsaWNlKDAsIGxlbmd0aERpZmYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzdW1EaWZmW2ldID0gc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzdW1EaWZmW2ldID0gR0YuYWRkKHNtYWxsZXJbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJbaV0pO1xuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChzdW1EaWZmKTtcbiAgICB9LFxuICAgIHJlbWFpbmRlclBvbHkoZGF0YSwgZGl2aXNvcikge1xuICAgICAgICBjb25zdCBvdXQgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gZGl2aXNvci5sZW5ndGggKyAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbSA9IG91dFtpXTtcbiAgICAgICAgICAgIGlmIChlbG0gPT09IDApXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGRpdmlzb3IubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2aXNvcltqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgb3V0W2kgKyBqXSA9IEdGLmFkZChvdXRbaSArIGpdLCBHRi5tdWwoZGl2aXNvcltqXSwgZWxtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dC5zbGljZShkYXRhLmxlbmd0aCAtIGRpdmlzb3IubGVuZ3RoICsgMSwgb3V0Lmxlbmd0aCk7XG4gICAgfSxcbiAgICBkaXZpc29yUG9seShkZWdyZWUpIHtcbiAgICAgICAgbGV0IGcgPSBbMV07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlOyBpKyspXG4gICAgICAgICAgICBnID0gR0YubXVsUG9seShnLCBbMSwgR0YucG93KDIsIGkpXSk7XG4gICAgICAgIHJldHVybiBnO1xuICAgIH0sXG4gICAgZXZhbFBvbHkocG9seSwgYSkge1xuICAgICAgICBpZiAoYSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIEdGLmNvZWZmaWNpZW50KHBvbHksIDApOyAvLyBKdXN0IHJldHVybiB0aGUgeF4wIGNvZWZmaWNpZW50XG4gICAgICAgIGxldCByZXMgPSBwb2x5WzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvbHkubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXMgPSBHRi5hZGQoR0YubXVsKGEsIHJlcyksIHBvbHlbaV0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgLy8gVE9ETzogY2xlYW51cFxuICAgIGV1Y2xpZGlhbihhLCBiLCBSKSB7XG4gICAgICAgIC8vIEZvcmNlIGRlZ3JlZShhKSA+PSBkZWdyZWUoYilcbiAgICAgICAgaWYgKEdGLmRlZ3JlZShhKSA8IEdGLmRlZ3JlZShiKSlcbiAgICAgICAgICAgIFthLCBiXSA9IFtiLCBhXTtcbiAgICAgICAgbGV0IHJMYXN0ID0gYTtcbiAgICAgICAgbGV0IHIgPSBiO1xuICAgICAgICBsZXQgdExhc3QgPSBbMF07XG4gICAgICAgIGxldCB0ID0gWzFdO1xuICAgICAgICAvLyB3aGlsZSBkZWdyZWUgb2YgUmkg4omlIHQvMlxuICAgICAgICB3aGlsZSAoMiAqIEdGLmRlZ3JlZShyKSA+PSBSKSB7XG4gICAgICAgICAgICBsZXQgckxhc3RMYXN0ID0gckxhc3Q7XG4gICAgICAgICAgICBsZXQgdExhc3RMYXN0ID0gdExhc3Q7XG4gICAgICAgICAgICByTGFzdCA9IHI7XG4gICAgICAgICAgICB0TGFzdCA9IHQ7XG4gICAgICAgICAgICBpZiAockxhc3RbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyTGFzdFswXSA9PT0gMCcpO1xuICAgICAgICAgICAgciA9IHJMYXN0TGFzdDtcbiAgICAgICAgICAgIGxldCBxID0gWzBdO1xuICAgICAgICAgICAgY29uc3QgZGx0SW52ZXJzZSA9IEdGLmludihyTGFzdFswXSk7XG4gICAgICAgICAgICB3aGlsZSAoR0YuZGVncmVlKHIpID49IEdGLmRlZ3JlZShyTGFzdCkgJiYgclswXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZURpZmYgPSBHRi5kZWdyZWUocikgLSBHRi5kZWdyZWUockxhc3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gR0YubXVsKHJbMF0sIGRsdEludmVyc2UpO1xuICAgICAgICAgICAgICAgIHEgPSBHRi5hZGRQb2x5KHEsIEdGLm1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgciA9IEdGLmFkZFBvbHkociwgR0YubXVsUG9seU1vbm9taWFsKHJMYXN0LCBkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcSA9IEdGLm11bFBvbHkocSwgdExhc3QpO1xuICAgICAgICAgICAgdCA9IEdGLmFkZFBvbHkocSwgdExhc3RMYXN0KTtcbiAgICAgICAgICAgIGlmIChHRi5kZWdyZWUocikgPj0gR0YuZGVncmVlKHJMYXN0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpdmlzaW9uIGZhaWxlZCByOiAke3J9LCByTGFzdDogJHtyTGFzdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWdtYVRpbGRlQXRaZXJvID0gR0YuY29lZmZpY2llbnQodCwgMCk7XG4gICAgICAgIGlmIChzaWdtYVRpbGRlQXRaZXJvID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ21hVGlsZGUoMCkgd2FzIHplcm8nKTtcbiAgICAgICAgY29uc3QgaW52ZXJzZSA9IEdGLmludihzaWdtYVRpbGRlQXRaZXJvKTtcbiAgICAgICAgcmV0dXJuIFtHRi5tdWxQb2x5U2NhbGFyKHQsIGludmVyc2UpLCBHRi5tdWxQb2x5U2NhbGFyKHIsIGludmVyc2UpXTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIFJTKGVjY1dvcmRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBHRi5kaXZpc29yUG9seShlY2NXb3Jkcyk7XG4gICAgICAgICAgICBjb25zdCBwb2wgPSBBcnJheS5mcm9tKGZyb20pO1xuICAgICAgICAgICAgcG9sLnB1c2goLi4uZC5zbGljZSgwLCAtMSkuZmlsbCgwKSk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEdGLnJlbWFpbmRlclBvbHkocG9sLCBkKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZSh0bykge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdG8uc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvbHkgPSBHRi5wb2x5bm9taWFsKEFycmF5LmZyb20odG8pKTtcbiAgICAgICAgICAgIC8vIEZpbmQgZXJyb3JzXG4gICAgICAgICAgICBsZXQgc3luZHJvbWUgPSBmaWxsQXJyKGVjY1dvcmRzLCAwKTtcbiAgICAgICAgICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlY2NXb3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZsID0gR0YuZXZhbFBvbHkocG9seSwgR0YuZXhwKGkpKTtcbiAgICAgICAgICAgICAgICBzeW5kcm9tZVtzeW5kcm9tZS5sZW5ndGggLSAxIC0gaV0gPSBldmw7XG4gICAgICAgICAgICAgICAgaWYgKGV2bCAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgc3luZHJvbWUgPSBHRi5wb2x5bm9taWFsKHN5bmRyb21lKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbm9taWFsID0gR0YubW9ub21pYWwoZWNjV29yZHMsIDEpO1xuICAgICAgICAgICAgY29uc3QgW2Vycm9yTG9jYXRvciwgZXJyb3JFdmFsdWF0b3JdID0gR0YuZXVjbGlkaWFuKG1vbm9taWFsLCBzeW5kcm9tZSwgZWNjV29yZHMpO1xuICAgICAgICAgICAgLy8gRXJyb3IgbG9jYXRpb25zXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbnMgPSBmaWxsQXJyKEdGLmRlZ3JlZShlcnJvckxvY2F0b3IpLCAwKTtcbiAgICAgICAgICAgIGxldCBlID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMjU2ICYmIGUgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoR0YuZXZhbFBvbHkoZXJyb3JMb2NhdG9yLCBpKSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25zW2UrK10gPSBHRi5pbnYoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZSAhPT0gbG9jYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JTLmRlY29kZTogaW52YWxpZCBlcnJvcnMgbnVtYmVyJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHJlcy5sZW5ndGggLSAxIC0gR0YubG9nKGxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA8IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlMuZGVjb2RlOiBpbnZhbGlkIGVycm9yIGxvY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeGlJbnZlcnNlID0gR0YuaW52KGxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2F0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gailcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBkZW5vbWluYXRvciA9IEdGLm11bChkZW5vbWluYXRvciwgR0YuYWRkKDEsIEdGLm11bChsb2NhdGlvbnNbal0sIHhpSW52ZXJzZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzW3Bvc10gPSBHRi5hZGQocmVzW3Bvc10sIEdGLm11bChHRi5ldmFsUG9seShlcnJvckV2YWx1YXRvciwgeGlJbnZlcnNlKSwgR0YuaW52KGRlbm9taW5hdG9yKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gSW50ZXJsZWF2ZXMgYmxvY2tzXG5mdW5jdGlvbiBpbnRlcmxlYXZlKHZlciwgZWNjKSB7XG4gICAgY29uc3QgeyB3b3Jkcywgc2hvcnRCbG9ja3MsIG51bUJsb2NrcywgYmxvY2tMZW4sIHRvdGFsIH0gPSBpbmZvLmNhcGFjaXR5KHZlciwgZWNjKTtcbiAgICBjb25zdCBycyA9IFJTKHdvcmRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIEFkZCBlcnJvciBjb3JyZWN0aW9uIHRvIGJ5dGVzXG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGVjY0Jsb2NrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2hvcnQgPSBpIDwgc2hvcnRCbG9ja3M7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gYmxvY2tMZW4gKyAoaXNTaG9ydCA/IDAgOiAxKTtcbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaChieXRlcy5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICAgICAgICAgICAgICBlY2NCbG9ja3MucHVzaChycy5lbmNvZGUoYnl0ZXMuc3ViYXJyYXkoMCwgbGVuKSkpO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc0Jsb2NrcyA9IGludGVybGVhdmVCeXRlcyhibG9ja3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzRUNDID0gaW50ZXJsZWF2ZUJ5dGVzKGVjY0Jsb2Nrcyk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShyZXNCbG9ja3MubGVuZ3RoICsgcmVzRUNDLmxlbmd0aCk7XG4gICAgICAgICAgICByZXMuc2V0KHJlc0Jsb2Nrcyk7XG4gICAgICAgICAgICByZXMuc2V0KHJlc0VDQywgcmVzQmxvY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0b3RhbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludGVybGVhdmUuZGVjb2RlOiBsZW4oZGF0YSk9JHtkYXRhLmxlbmd0aH0sIHRvdGFsPSR7dG90YWx9YCk7XG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Nob3J0ID0gaSA8IHNob3J0QmxvY2tzO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBVaW50OEFycmF5KHdvcmRzICsgYmxvY2tMZW4gKyAoaXNTaG9ydCA/IDAgOiAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2hvcnQgYmxvY2tzXG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQmxvY2tzOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tqXVtpXSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9uZyBibG9ja3NcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBzaG9ydEJsb2NrczsgaiA8IG51bUJsb2NrczsgaisrKVxuICAgICAgICAgICAgICAgIGJsb2Nrc1tqXVtibG9ja0xlbl0gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIC8vIEVDQ1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJsb2NrTGVuOyBpIDwgYmxvY2tMZW4gKyB3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1CbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Nob3J0ID0gaiA8IHNob3J0QmxvY2tzO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3Nbal1baSArIChpc1Nob3J0ID8gMCA6IDEpXSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZVxuICAgICAgICAgICAgLy8gRXJyb3ItY29ycmVjdCBhbmQgY29weSBkYXRhIGJsb2NrcyB0b2dldGhlciBpbnRvIGEgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKC4uLkFycmF5LmZyb20ocnMuZGVjb2RlKGJsb2NrKSkuc2xpY2UoMCwgLXdvcmRzKSk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIERyYXdcbi8vIEdlbmVyaWMgdGVtcGxhdGUgcGVyIHZlcnNpb24rZWNjK21hc2suIENhbiBiZSBjYWNoZWQsIHRvIHNwZWVkdXAgY2FsY3VsYXRpb25zLlxuZnVuY3Rpb24gZHJhd1RlbXBsYXRlKHZlciwgZWNjLCBtYXNrSWR4LCB0ZXN0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzaXplID0gaW5mby5zaXplLmVuY29kZSh2ZXIpO1xuICAgIGxldCBiID0gbmV3IEJpdG1hcChzaXplICsgMik7XG4gICAgLy8gRmluZGVyIHBhdHRlcm5zXG4gICAgLy8gV2UgZHJhdyBmdWxsIHBhdHRlcm4gYW5kIGxhdGVyIHNsaWNlLCBzaW5jZSBiZWZvcmUgYWRkaXRpb24gb2YgYm9yZGVycyBmaW5kZXIgaXMgdHJ1bmNhdGVkIGJ5IG9uZSBwaXhlbCBvbiBzaWRlc1xuICAgIGNvbnN0IGZpbmRlciA9IG5ldyBCaXRtYXAoMykucmVjdCgwLCAzLCB0cnVlKS5ib3JkZXIoMSwgZmFsc2UpLmJvcmRlcigxLCB0cnVlKS5ib3JkZXIoMSwgZmFsc2UpO1xuICAgIGIgPSBiXG4gICAgICAgIC5lbWJlZCgwLCBmaW5kZXIpIC8vIHRvcCBsZWZ0XG4gICAgICAgIC5lbWJlZCh7IHg6IC1maW5kZXIud2lkdGgsIHk6IDAgfSwgZmluZGVyKSAvLyB0b3AgcmlnaHRcbiAgICAgICAgLmVtYmVkKHsgeDogMCwgeTogLWZpbmRlci5oZWlnaHQgfSwgZmluZGVyKTsgLy8gYm90dG9tIGxlZnRcbiAgICBiID0gYi5yZWN0U2xpY2UoMSwgc2l6ZSk7XG4gICAgLy8gQWxpZ25tZW50IHBhdHRlcm5zXG4gICAgY29uc3QgYWxpZ24gPSBuZXcgQml0bWFwKDEpLnJlY3QoMCwgMSwgdHJ1ZSkuYm9yZGVyKDEsIGZhbHNlKS5ib3JkZXIoMSwgdHJ1ZSk7XG4gICAgY29uc3QgYWxpZ25Qb3MgPSBpbmZvLmFsaWdubWVudFBhdHRlcm5zKHZlcik7XG4gICAgZm9yIChjb25zdCB5IG9mIGFsaWduUG9zKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiBhbGlnblBvcykge1xuICAgICAgICAgICAgaWYgKGIuZGF0YVt5XVt4XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgYi5lbWJlZCh7IHg6IHggLSAyLCB5OiB5IC0gMiB9LCBhbGlnbik7IC8vIGNlbnRlciBvZiBwYXR0ZXJuIHNob3VsZCBiZSBhdCBwb3NpdGlvblxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRpbWluZyBwYXR0ZXJuc1xuICAgIGIgPSBiXG4gICAgICAgIC5oTGluZSh7IHg6IDAsIHk6IDYgfSwgSW5maW5pdHksICh7IHggfSwgY3VyKSA9PiAoY3VyID09PSB1bmRlZmluZWQgPyB4ICUgMiA9PSAwIDogY3VyKSlcbiAgICAgICAgLnZMaW5lKHsgeDogNiwgeTogMCB9LCBJbmZpbml0eSwgKHsgeSB9LCBjdXIpID0+IChjdXIgPT09IHVuZGVmaW5lZCA/IHkgJSAyID09IDAgOiBjdXIpKTtcbiAgICAvLyBGb3JtYXQgaW5mb3JtYXRpb25cbiAgICB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBpbmZvLmZvcm1hdEJpdHMoZWNjLCBtYXNrSWR4KTtcbiAgICAgICAgY29uc3QgZ2V0Qml0ID0gKGkpID0+ICF0ZXN0ICYmICgoYml0cyA+PiBpKSAmIDEpID09IDE7XG4gICAgICAgIC8vIHZlcnRpY2FsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICAgICAgYi5kYXRhW2ldWzhdID0gZ2V0Qml0KGkpOyAvLyByaWdodCBvZiB0b3AtbGVmdCBmaW5kZXJcbiAgICAgICAgLy8gVE9ETzogcmUtd3JpdGUgYXMgbGluZXMsIGxpa2U6XG4gICAgICAgIC8vIGIudkxpbmUoeyB4OiA4LCB5OiAwIH0sIDYsICh7IHgsIHkgfSkgPT4gZ2V0Qml0KHkpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDY7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbaSArIDFdWzhdID0gZ2V0Qml0KGkpOyAvLyBhZnRlciB0aW1pbmcgcGF0dGVyblxuICAgICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbc2l6ZSAtIDE1ICsgaV1bOF0gPSBnZXRCaXQoaSk7IC8vIHJpZ2h0IG9mIGJvdHRvbS1sZWZ0IGZpbmRlclxuICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgYi5kYXRhWzhdW3NpemUgLSBpIC0gMV0gPSBnZXRCaXQoaSk7IC8vIHVuZGVyIHRvcC1yaWdodCBmaW5kZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCA5OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbOF1bMTUgLSBpIC0gMSArIDFdID0gZ2V0Qml0KGkpOyAvLyBWVlYsIGFmdGVyIHRpbWluZ1xuICAgICAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbOF1bMTUgLSBpIC0gMV0gPSBnZXRCaXQoaSk7IC8vIHVuZGVyIHRvcC1sZWZ0IGZpbmRlclxuICAgICAgICBiLmRhdGFbc2l6ZSAtIDhdWzhdID0gIXRlc3Q7IC8vIGJvdHRvbS1sZWZ0IGZpbmRlciwgcmlnaHRcbiAgICB9XG4gICAgLy8gVmVyc2lvbiBpbmZvcm1hdGlvblxuICAgIGlmICh2ZXIgPj0gNykge1xuICAgICAgICBjb25zdCBiaXRzID0gaW5mby52ZXJzaW9uQml0cyh2ZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE4OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdCA9ICF0ZXN0ICYmICgoYml0cyA+PiBpKSAmIDEpID09IDE7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihpIC8gMyk7XG4gICAgICAgICAgICBjb25zdCB5ID0gKGkgJSAzKSArIHNpemUgLSA4IC0gMztcbiAgICAgICAgICAgIC8vIHR3byBjb3BpZXNcbiAgICAgICAgICAgIGIuZGF0YVt4XVt5XSA9IGJpdDtcbiAgICAgICAgICAgIGIuZGF0YVt5XVt4XSA9IGJpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8vIHppZ3phZzogYm90dG9tLT50b3AgJiYgdG9wLT5ib3R0b21cbmZ1bmN0aW9uIHppZ3phZyh0cGwsIG1hc2tJZHgsIGZuKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRwbC5oZWlnaHQ7XG4gICAgY29uc3QgcGF0dGVybiA9IFBBVFRFUk5TW21hc2tJZHhdO1xuICAgIC8vIHppZy16YWcgcGF0dGVyblxuICAgIGxldCBkaXIgPSAtMTtcbiAgICBsZXQgeSA9IHNpemUgLSAxO1xuICAgIC8vIHR3byBjb2x1bW5zIGF0IHRpbWVcbiAgICBmb3IgKGxldCB4T2Zmc2V0ID0gc2l6ZSAtIDE7IHhPZmZzZXQgPiAwOyB4T2Zmc2V0IC09IDIpIHtcbiAgICAgICAgaWYgKHhPZmZzZXQgPT0gNilcbiAgICAgICAgICAgIHhPZmZzZXQgPSA1OyAvLyBza2lwIHZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgIGZvciAoOzsgeSArPSBkaXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhPZmZzZXQgLSBqO1xuICAgICAgICAgICAgICAgIGlmICh0cGwuZGF0YVt5XVt4XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBhbHJlYWR5IHdyaXR0ZW4gZWxlbWVudHNcbiAgICAgICAgICAgICAgICBmbih4LCB5LCBwYXR0ZXJuKHgsIHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICsgZGlyIDwgMCB8fCB5ICsgZGlyID49IHNpemUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGlyID0gLWRpcjsgLy8gY2hhbmdlIGRpcmVjdGlvblxuICAgIH1cbn1cbi8vIE5PVEU6IGJ5dGUgZW5jb2RpbmcgaXMganVzdCByZXByZXNlbnRhdGlvbiwgUVIgd29ya3Mgd2l0aCBzdHJpbmdzIG9ubHkuIE1vc3QgZGVjb2RlcnMgd2lsbCBmYWlsIG9uIHJhdyBieXRlIGFycmF5LFxuLy8gc2luY2UgdGhleSBleHBlY3QgdW5pY29kZSBvciBvdGhlciB0ZXh0IGVuY29kaW5nIGluc2lkZSBieXRlc1xuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdHIpIHtcbiAgICBsZXQgdHlwZSA9ICdudW1lcmljJztcbiAgICBmb3IgKGxldCB4IG9mIHN0cikge1xuICAgICAgICBpZiAoaW5mby5hbHBoYWJldC5udW1lcmljLmhhcyh4KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0eXBlID0gJ2FscGhhbnVtZXJpYyc7XG4gICAgICAgIGlmICghaW5mby5hbHBoYWJldC5hbHBoYW51bWVyYy5oYXMoeCkpXG4gICAgICAgICAgICByZXR1cm4gJ2J5dGUnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZnVuY3Rpb24gZW5jb2RlKHZlciwgZWNjLCBkYXRhLCB0eXBlLCBlbmNvZGVyID0gdXRmOFRvQnl0ZXMpIHtcbiAgICBsZXQgZW5jb2RlZCA9ICcnO1xuICAgIGxldCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgICBjb25zdCB0ID0gaW5mby5hbHBoYWJldC5udW1lcmljLmRlY29kZShkYXRhLnNwbGl0KCcnKSk7XG4gICAgICAgIGNvbnN0IG4gPSB0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuIC0gMjsgaSArPSAzKVxuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtpXSAqIDEwMCArIHRbaSArIDFdICogMTAgKyB0W2kgKyAyXSwgMTApO1xuICAgICAgICBpZiAobiAlIDMgPT09IDEpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbbiAtIDFdLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuICUgMyA9PT0gMikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtuIC0gMl0gKiAxMCArIHRbbiAtIDFdLCA3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYWxwaGFudW1lcmljJykge1xuICAgICAgICBjb25zdCB0ID0gaW5mby5hbHBoYWJldC5hbHBoYW51bWVyYy5kZWNvZGUoZGF0YS5zcGxpdCgnJykpO1xuICAgICAgICBjb25zdCBuID0gdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkgKz0gMilcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbaV0gKiA0NSArIHRbaSArIDFdLCAxMSk7XG4gICAgICAgIGlmIChuICUgMiA9PSAxKVxuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtuIC0gMV0sIDYpOyAvLyBwYWQgaWYgb2RkIG51bWJlciBvZiBjaGFyc1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYnl0ZScpIHtcbiAgICAgICAgY29uc3QgdXRmOCA9IGVuY29kZXIoZGF0YSk7XG4gICAgICAgIGRhdGFMZW4gPSB1dGY4Lmxlbmd0aDtcbiAgICAgICAgZW5jb2RlZCA9IEFycmF5LmZyb20odXRmOClcbiAgICAgICAgICAgIC5tYXAoKGkpID0+IGJpbihpLCA4KSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb2RlOiB1bnN1cHBvcnRlZCB0eXBlJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2FwYWNpdHkgfSA9IGluZm8uY2FwYWNpdHkodmVyLCBlY2MpO1xuICAgIGNvbnN0IGxlbiA9IGJpbihkYXRhTGVuLCBpbmZvLmxlbmd0aEJpdHModmVyLCB0eXBlKSk7XG4gICAgbGV0IGJpdHMgPSBpbmZvLm1vZGVCaXRzW3R5cGVdICsgbGVuICsgZW5jb2RlZDtcbiAgICBpZiAoYml0cy5sZW5ndGggPiBjYXBhY2l0eSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYXBhY2l0eSBvdmVyZmxvdycpO1xuICAgIC8vIFRlcm1pbmF0b3JcbiAgICBiaXRzICs9ICcwJy5yZXBlYXQoTWF0aC5taW4oNCwgTWF0aC5tYXgoMCwgY2FwYWNpdHkgLSBiaXRzLmxlbmd0aCkpKTtcbiAgICAvLyBQYWQgYml0cyBzdHJpbmcgdW50aWxsIGZ1bGwgYnl0ZVxuICAgIGlmIChiaXRzLmxlbmd0aCAlIDgpXG4gICAgICAgIGJpdHMgKz0gJzAnLnJlcGVhdCg4IC0gKGJpdHMubGVuZ3RoICUgOCkpO1xuICAgIC8vIEFkZCBwYWRkaW5nIHVudGlsIGNhcGFjaXR5IGlzIGZ1bGxcbiAgICBjb25zdCBwYWRkaW5nID0gJzExMTAxMTAwMDAwMTAwMDEnO1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGJpdHMubGVuZ3RoICE9PSBjYXBhY2l0eTsgaWR4KyspXG4gICAgICAgIGJpdHMgKz0gcGFkZGluZ1tpZHggJSBwYWRkaW5nLmxlbmd0aF07XG4gICAgLy8gQ29udmVydCBhIGJpdHN0cmluZyB0byBhcnJheSBvZiBieXRlc1xuICAgIGNvbnN0IGJ5dGVzID0gVWludDhBcnJheS5mcm9tKGJpdHMubWF0Y2goLyguezh9KS9nKS5tYXAoKGkpID0+IE51bWJlcihgMGIke2l9YCkpKTtcbiAgICByZXR1cm4gaW50ZXJsZWF2ZSh2ZXIsIGVjYykuZW5jb2RlKGJ5dGVzKTtcbn1cbi8vIERSQVdcbmZ1bmN0aW9uIGRyYXdRUih2ZXIsIGVjYywgZGF0YSwgbWFza0lkeCwgdGVzdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgYiA9IGRyYXdUZW1wbGF0ZSh2ZXIsIGVjYywgbWFza0lkeCwgdGVzdCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IG5lZWQgPSA4ICogZGF0YS5sZW5ndGg7XG4gICAgemlnemFnKGIsIG1hc2tJZHgsICh4LCB5LCBtYXNrKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaSA8IG5lZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKChkYXRhW2kgPj4+IDNdID4+ICgoNyAtIGkpICYgNykpICYgMSkgIT09IDA7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgYi5kYXRhW3ldW3hdID0gdmFsdWUgIT09IG1hc2s7IC8vICE9PSBhcyB4b3JcbiAgICB9KTtcbiAgICBpZiAoaSAhPT0gbmVlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRUjogYnl0ZXMgbGVmdCBhZnRlciBkcmF3Jyk7XG4gICAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSb3dSdW5QZW5hbHR5KHJvd0JpdHMpIHtcbiAgICBjb25zdCBtb2R1bGVDb3VudCA9IHJvd0JpdHMubGVuZ3RoO1xuICAgIGlmIChtb2R1bGVDb3VudCA8PSAxKVxuICAgICAgICByZXR1cm4gMDtcbiAgICBsZXQgcGVuYWx0eSA9IDA7XG4gICAgbGV0IHJ1bkxlbmd0aCA9IDE7XG4gICAgbGV0IHByZXZpb3VzQ29sb3IgPSByb3dCaXRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbW9kdWxlQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sb3IgPSByb3dCaXRzW2ldO1xuICAgICAgICBpZiAoY3VycmVudENvbG9yID09PSBwcmV2aW91c0NvbG9yKSB7XG4gICAgICAgICAgICBydW5MZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChydW5MZW5ndGggPj0gUjFfUlVOX0xFTkdUSF9USFJFU0hPTEQpXG4gICAgICAgICAgICAgICAgcGVuYWx0eSArPSBydW5MZW5ndGggLSAyO1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHByZXZpb3VzQ29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJ1bkxlbmd0aCA+PSBSMV9SVU5fTEVOR1RIX1RIUkVTSE9MRClcbiAgICAgICAgcGVuYWx0eSArPSBydW5MZW5ndGggLSAyO1xuICAgIHJldHVybiBwZW5hbHR5O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ29sdW1uUnVuUGVuYWx0eShiaXRtYXAsIGNvbHVtbkluZGV4LCBjb2x1bW5IZWlnaHQpIHtcbiAgICBpZiAoY29sdW1uSGVpZ2h0IDw9IDEpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBwZW5hbHR5ID0gMDtcbiAgICBsZXQgcnVuTGVuZ3RoID0gMTtcbiAgICBsZXQgcHJldmlvdXNDb2xvciA9IGJpdG1hcFswXVtjb2x1bW5JbmRleF07XG4gICAgZm9yIChsZXQgeSA9IDE7IHkgPCBjb2x1bW5IZWlnaHQ7IHkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q29sb3IgPSBiaXRtYXBbeV1bY29sdW1uSW5kZXhdO1xuICAgICAgICBpZiAoY3VycmVudENvbG9yID09PSBwcmV2aW91c0NvbG9yKSB7XG4gICAgICAgICAgICBydW5MZW5ndGgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChydW5MZW5ndGggPj0gUjFfUlVOX0xFTkdUSF9USFJFU0hPTEQpXG4gICAgICAgICAgICAgICAgcGVuYWx0eSArPSBydW5MZW5ndGggLSAyO1xuICAgICAgICAgICAgcnVuTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHByZXZpb3VzQ29sb3IgPSBjdXJyZW50Q29sb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJ1bkxlbmd0aCA+PSBSMV9SVU5fTEVOR1RIX1RIUkVTSE9MRClcbiAgICAgICAgcGVuYWx0eSArPSBydW5MZW5ndGggLSAyO1xuICAgIHJldHVybiBwZW5hbHR5O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUm93RmluZGVyUGVuYWx0eShyb3dCaXRzKSB7XG4gICAgY29uc3Qgcm93TGVuZ3RoID0gcm93Qml0cy5sZW5ndGg7XG4gICAgaWYgKHJvd0xlbmd0aCA8IFIzX0ZJTkRFUl9QQVRURVJOX0xFTkdUSClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IHBlbmFsdHkgPSAwO1xuICAgIGNvbnN0IGxhc3RTdGFydCA9IHJvd0xlbmd0aCAtIFIzX0ZJTkRFUl9QQVRURVJOX0xFTkdUSDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0U3RhcnQ7IGkrKykge1xuICAgICAgICAvLyBDYXNlIEE6IEwgTCBMIEwgKyAxIDAgMSAxIDEgMCAxXG4gICAgICAgIGNvbnN0IGxpZ2h0NFRoZW5GaW5kZXI3ID0gIXJvd0JpdHNbaV0gJiZcbiAgICAgICAgICAgICFyb3dCaXRzW2kgKyAxXSAmJlxuICAgICAgICAgICAgIXJvd0JpdHNbaSArIDJdICYmXG4gICAgICAgICAgICAhcm93Qml0c1tpICsgM10gJiZcbiAgICAgICAgICAgIHJvd0JpdHNbaSArIDRdICYmXG4gICAgICAgICAgICAhcm93Qml0c1tpICsgNV0gJiZcbiAgICAgICAgICAgIHJvd0JpdHNbaSArIDZdICYmXG4gICAgICAgICAgICByb3dCaXRzW2kgKyA3XSAmJlxuICAgICAgICAgICAgcm93Qml0c1tpICsgOF0gJiZcbiAgICAgICAgICAgICFyb3dCaXRzW2kgKyA5XSAmJlxuICAgICAgICAgICAgcm93Qml0c1tpICsgMTBdO1xuICAgICAgICAvLyBDYXNlIEI6IDEgMCAxIDEgMSAwIDEgKyBMIEwgTCBMXG4gICAgICAgIGNvbnN0IGZpbmRlcjdUaGVuTGlnaHQ0ID0gcm93Qml0c1tpXSAmJlxuICAgICAgICAgICAgIXJvd0JpdHNbaSArIDFdICYmXG4gICAgICAgICAgICByb3dCaXRzW2kgKyAyXSAmJlxuICAgICAgICAgICAgcm93Qml0c1tpICsgM10gJiZcbiAgICAgICAgICAgIHJvd0JpdHNbaSArIDRdICYmXG4gICAgICAgICAgICAhcm93Qml0c1tpICsgNV0gJiZcbiAgICAgICAgICAgIHJvd0JpdHNbaSArIDZdICYmXG4gICAgICAgICAgICAhcm93Qml0c1tpICsgN10gJiZcbiAgICAgICAgICAgICFyb3dCaXRzW2kgKyA4XSAmJlxuICAgICAgICAgICAgIXJvd0JpdHNbaSArIDldICYmXG4gICAgICAgICAgICAhcm93Qml0c1tpICsgMTBdO1xuICAgICAgICBpZiAobGlnaHQ0VGhlbkZpbmRlcjcgfHwgZmluZGVyN1RoZW5MaWdodDQpXG4gICAgICAgICAgICBwZW5hbHR5ICs9IFIzX0ZJTkRFUl9QRU5BTFRZO1xuICAgIH1cbiAgICByZXR1cm4gcGVuYWx0eTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbHVtbkZpbmRlclBlbmFsdHkobWF0cml4LCByb3dJbmRleCwgd2lkdGgpIHtcbiAgICBpZiAod2lkdGggPCBSM19GSU5ERVJfUEFUVEVSTl9MRU5HVEgpXG4gICAgICAgIHJldHVybiAwO1xuICAgIGxldCBwZW5hbHR5ID0gMDtcbiAgICBjb25zdCB5ID0gcm93SW5kZXg7XG4gICAgY29uc3QgbGFzdFN0YXJ0ID0gd2lkdGggLSBSM19GSU5ERVJfUEFUVEVSTl9MRU5HVEg7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPD0gbGFzdFN0YXJ0OyB4KyspIHtcbiAgICAgICAgLy8gQ2FzZSBBOiBMIEwgTCBMICsgMSAwIDEgMSAxIDAgMVxuICAgICAgICBjb25zdCBsaWdodDRUaGVuRmluZGVyNyA9ICFtYXRyaXhbeF1beV0gJiZcbiAgICAgICAgICAgICFtYXRyaXhbeCArIDFdW3ldICYmXG4gICAgICAgICAgICAhbWF0cml4W3ggKyAyXVt5XSAmJlxuICAgICAgICAgICAgIW1hdHJpeFt4ICsgM11beV0gJiZcbiAgICAgICAgICAgIG1hdHJpeFt4ICsgNF1beV0gJiZcbiAgICAgICAgICAgICFtYXRyaXhbeCArIDVdW3ldICYmXG4gICAgICAgICAgICBtYXRyaXhbeCArIDZdW3ldICYmXG4gICAgICAgICAgICBtYXRyaXhbeCArIDddW3ldICYmXG4gICAgICAgICAgICBtYXRyaXhbeCArIDhdW3ldICYmXG4gICAgICAgICAgICAhbWF0cml4W3ggKyA5XVt5XSAmJlxuICAgICAgICAgICAgbWF0cml4W3ggKyAxMF1beV07XG4gICAgICAgIC8vIENhc2UgQjogMSAwIDEgMSAxIDAgMSArIEwgTCBMIExcbiAgICAgICAgY29uc3QgZmluZGVyN1RoZW5MaWdodDQgPSBtYXRyaXhbeF1beV0gJiZcbiAgICAgICAgICAgICFtYXRyaXhbeCArIDFdW3ldICYmXG4gICAgICAgICAgICBtYXRyaXhbeCArIDJdW3ldICYmXG4gICAgICAgICAgICBtYXRyaXhbeCArIDNdW3ldICYmXG4gICAgICAgICAgICBtYXRyaXhbeCArIDRdW3ldICYmXG4gICAgICAgICAgICAhbWF0cml4W3ggKyA1XVt5XSAmJlxuICAgICAgICAgICAgbWF0cml4W3ggKyA2XVt5XSAmJlxuICAgICAgICAgICAgIW1hdHJpeFt4ICsgN11beV0gJiZcbiAgICAgICAgICAgICFtYXRyaXhbeCArIDhdW3ldICYmXG4gICAgICAgICAgICAhbWF0cml4W3ggKyA5XVt5XSAmJlxuICAgICAgICAgICAgIW1hdHJpeFt4ICsgMTBdW3ldO1xuICAgICAgICBpZiAobGlnaHQ0VGhlbkZpbmRlcjcgfHwgZmluZGVyN1RoZW5MaWdodDQpXG4gICAgICAgICAgICBwZW5hbHR5ICs9IFIzX0ZJTkRFUl9QRU5BTFRZO1xuICAgIH1cbiAgICByZXR1cm4gcGVuYWx0eTtcbn1cbmZ1bmN0aW9uIHBlbmFsdHkoYml0bWFwKSB7XG4gICAgY29uc3QgbWF0cml4ID0gYml0bWFwLmRhdGE7XG4gICAgY29uc3Qgd2lkdGggPSBiaXRtYXAud2lkdGggfCAwO1xuICAgIGNvbnN0IGhlaWdodCA9IGJpdG1hcC5oZWlnaHQgfCAwO1xuICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIC8vIFJ1bGUgMTogc2FtZS1jb2xvciBydW5zXG4gICAgbGV0IHJ1blBlbmFsdHkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKylcbiAgICAgICAgcnVuUGVuYWx0eSArPSBjYWxjdWxhdGVSb3dSdW5QZW5hbHR5KG1hdHJpeFt4XSk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKylcbiAgICAgICAgcnVuUGVuYWx0eSArPSBjYWxjdWxhdGVDb2x1bW5SdW5QZW5hbHR5KG1hdHJpeCwgeSwgd2lkdGgpO1xuICAgIC8vIFJ1bGUgMjogMsOXMiBibG9ja3Mgb2YgdGhlIHNhbWUgY29sb3JcbiAgICBsZXQgYmxvY2tQZW5hbHR5ID0gMDtcbiAgICBjb25zdCBsYXN0Q29sID0gd2lkdGggLSAxO1xuICAgIGNvbnN0IGxhc3RSb3cgPSBoZWlnaHQgLSAxO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgbGFzdENvbDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IG1hdHJpeFt4XTtcbiAgICAgICAgY29uc3QgbmV4dENvbCA9IG1hdHJpeFt4ICsgMV07XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgbGFzdFJvdzsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gY29sW3ldO1xuICAgICAgICAgICAgaWYgKGNlbGwgPT09IG5leHRDb2xbeV0gJiYgY2VsbCA9PT0gY29sW3kgKyAxXSAmJiBjZWxsID09PSBuZXh0Q29sW3kgKyAxXSkge1xuICAgICAgICAgICAgICAgIGJsb2NrUGVuYWx0eSArPSBSMl9CTE9DS19QRU5BTFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJ1bGUgMzogZmluZGVyLWxpa2UgMToxOjM6MToxIHdpdGggNC1saWdodCBwYWRkaW5nXG4gICAgbGV0IGZpbmRlclBlbmFsdHkgPSAwO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKylcbiAgICAgICAgZmluZGVyUGVuYWx0eSArPSBjYWxjdWxhdGVSb3dGaW5kZXJQZW5hbHR5KG1hdHJpeFt4XSk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKylcbiAgICAgICAgZmluZGVyUGVuYWx0eSArPSBjYWxjdWxhdGVDb2x1bW5GaW5kZXJQZW5hbHR5KG1hdHJpeCwgeSwgd2lkdGgpO1xuICAgIC8vIFJ1bGUgNDogZGFyay1tb2R1bGUgYmFsYW5jZSB2cyA1MCVcbiAgICBsZXQgZGFya0NvdW50ID0gMDtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgY29uc3QgY29sID0gbWF0cml4W3hdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKVxuICAgICAgICAgICAgaWYgKGNvbFt5XSlcbiAgICAgICAgICAgICAgICBkYXJrQ291bnQrKztcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlQ291bnQgPSB3aWR0aCAqIGhlaWdodDtcbiAgICBjb25zdCBkYXJrUGVyY2VudCA9IChkYXJrQ291bnQgKiAxMDApIC8gbW9kdWxlQ291bnQ7XG4gICAgY29uc3QgZGV2aWF0aW9uID0gTWF0aC5hYnMoZGFya1BlcmNlbnQgLSA1MCk7XG4gICAgY29uc3QgYmFsYW5jZVBlbmFsdHkgPSBSNF9CQUxBTkNFX1NURVBfUE9JTlRTICogTWF0aC5mbG9vcihkZXZpYXRpb24gLyBSNF9CQUxBTkNFX1NURVBfUEVSQ0VOVCk7XG4gICAgcmV0dXJuIHJ1blBlbmFsdHkgKyBibG9ja1BlbmFsdHkgKyBmaW5kZXJQZW5hbHR5ICsgYmFsYW5jZVBlbmFsdHk7XG59XG4vLyBTZWxlY3RzIGJlc3QgbWFzayBhY2NvcmRpbmcgdG8gcGVuYWx0eSwgaWYgbm8gbWFzayBpcyBwcm92aWRlZFxuZnVuY3Rpb24gZHJhd1FSQmVzdCh2ZXIsIGVjYywgZGF0YSwgbWFza0lkeCkge1xuICAgIGlmIChtYXNrSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYmVzdE1hc2sgPSBiZXN0KCk7XG4gICAgICAgIGZvciAobGV0IG1hc2sgPSAwOyBtYXNrIDwgUEFUVEVSTlMubGVuZ3RoOyBtYXNrKyspXG4gICAgICAgICAgICBiZXN0TWFzay5hZGQocGVuYWx0eShkcmF3UVIodmVyLCBlY2MsIGRhdGEsIG1hc2ssIHRydWUpKSwgbWFzayk7XG4gICAgICAgIG1hc2tJZHggPSBiZXN0TWFzay5nZXQoKTtcbiAgICB9XG4gICAgaWYgKG1hc2tJZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBtYXNrJyk7IC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICByZXR1cm4gZHJhd1FSKHZlciwgZWNjLCBkYXRhLCBtYXNrSWR4KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRUNDKGVjKSB7XG4gICAgaWYgKCFFQ01vZGUuaW5jbHVkZXMoZWMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXJyb3IgY29ycmVjdGlvbiBtb2RlPSR7ZWN9LiBFeHBlY3RlZDogJHtFQ01vZGV9YCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVuY29kaW5nKGVuYykge1xuICAgIGlmICghRW5jb2RpbmcuaW5jbHVkZXMoZW5jKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbmNvZGluZzogaW52YWxpZCBtb2RlPSR7ZW5jfS4gRXhwZWN0ZWQ6ICR7RW5jb2Rpbmd9YCk7XG4gICAgaWYgKGVuYyA9PT0gJ2thbmppJyB8fCBlbmMgPT09ICdlY2knKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuY29kaW5nOiAke2VuY30gaXMgbm90IHN1cHBvcnRlZCAoeWV0PykuYCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1hc2sobWFzaykge1xuICAgIGlmICghWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDddLmluY2x1ZGVzKG1hc2spIHx8ICFQQVRURVJOU1ttYXNrXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1hc2s9JHttYXNrfS4gRXhwZWN0ZWQgbnVtYmVyIFswLi43XWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVFSKHRleHQsIG91dHB1dCA9ICdyYXcnLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBlY2MgPSBvcHRzLmVjYyAhPT0gdW5kZWZpbmVkID8gb3B0cy5lY2MgOiAnbWVkaXVtJztcbiAgICB2YWxpZGF0ZUVDQyhlY2MpO1xuICAgIGNvbnN0IGVuY29kaW5nID0gb3B0cy5lbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gb3B0cy5lbmNvZGluZyA6IGRldGVjdFR5cGUodGV4dCk7XG4gICAgdmFsaWRhdGVFbmNvZGluZyhlbmNvZGluZyk7XG4gICAgaWYgKG9wdHMubWFzayAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB2YWxpZGF0ZU1hc2sob3B0cy5tYXNrKTtcbiAgICBsZXQgdmVyID0gb3B0cy52ZXJzaW9uO1xuICAgIGxldCBkYXRhLCBlcnIgPSBuZXcgRXJyb3IoJ1Vua25vd24gZXJyb3InKTtcbiAgICBpZiAodmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsaWRhdGVWZXJzaW9uKHZlcik7XG4gICAgICAgIGRhdGEgPSBlbmNvZGUodmVyLCBlY2MsIHRleHQsIGVuY29kaW5nLCBvcHRzLnRleHRFbmNvZGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIG5vIHZlcnNpb24gaXMgcHJvdmlkZWQsIHRyeSB0byBmaW5kIHNtYWxsZXN0IG9uZSB3aGljaCBmaXRzXG4gICAgICAgIC8vIEN1cnJlbnRseSBqdXN0IHNjYW5zIGFsbCB2ZXJzaW9uLCBjYW4gYmUgc2lnbmlmaWNhbnRseSBzcGVlZHVwIGlmIG5lZWRlZFxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSA0MDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBlbmNvZGUoaSwgZWNjLCB0ZXh0LCBlbmNvZGluZywgb3B0cy50ZXh0RW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgdmVyID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZlciB8fCAhZGF0YSlcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIGxldCByZXMgPSBkcmF3UVJCZXN0KHZlciwgZWNjLCBkYXRhLCBvcHRzLm1hc2spO1xuICAgIHJlcy5hc3NlcnREcmF3bigpO1xuICAgIGNvbnN0IGJvcmRlciA9IG9wdHMuYm9yZGVyID09PSB1bmRlZmluZWQgPyAyIDogb3B0cy5ib3JkZXI7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihib3JkZXIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYm9yZGVyIHR5cGU9JHt0eXBlb2YgYm9yZGVyfWApO1xuICAgIHJlcyA9IHJlcy5ib3JkZXIoYm9yZGVyLCBmYWxzZSk7IC8vIEFkZCBib3JkZXJcbiAgICBpZiAob3B0cy5zY2FsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXMgPSByZXMuc2NhbGUob3B0cy5zY2FsZSk7IC8vIFNjYWxlIGltYWdlXG4gICAgaWYgKG91dHB1dCA9PT0gJ3JhdycpXG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICBlbHNlIGlmIChvdXRwdXQgPT09ICdhc2NpaScpXG4gICAgICAgIHJldHVybiByZXMudG9BU0NJSSgpO1xuICAgIGVsc2UgaWYgKG91dHB1dCA9PT0gJ3N2ZycpXG4gICAgICAgIHJldHVybiByZXMudG9TVkcob3B0cy5vcHRpbWl6ZSk7XG4gICAgZWxzZSBpZiAob3V0cHV0ID09PSAnZ2lmJylcbiAgICAgICAgcmV0dXJuIHJlcy50b0dJRigpO1xuICAgIGVsc2UgaWYgKG91dHB1dCA9PT0gJ3Rlcm0nKVxuICAgICAgICByZXR1cm4gcmVzLnRvVGVybSgpO1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG91dHB1dDogJHtvdXRwdXR9YCk7XG59XG5leHBvcnQgZGVmYXVsdCBlbmNvZGVRUjtcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBiZXN0LFxuICAgIGJpbixcbiAgICBkcmF3VGVtcGxhdGUsXG4gICAgZmlsbEFycixcbiAgICBpbmZvLFxuICAgIGludGVybGVhdmUsXG4gICAgdmFsaWRhdGVWZXJzaW9uLFxuICAgIHppZ3phZyxcbn07XG4vLyBVbnNhZmUgQVBJIHV0aWxzLCBleHBvcnRlZCBvbmx5IGZvciB0ZXN0c1xuZXhwb3J0IGNvbnN0IF90ZXN0cyA9IHtcbiAgICBCaXRtYXAsXG4gICAgaW5mbyxcbiAgICBkZXRlY3RUeXBlLFxuICAgIGVuY29kZSxcbiAgICBkcmF3UVIsXG4gICAgcGVuYWx0eSxcbiAgICBQQVRURVJOUyxcbn07XG4vLyBUeXBlIHRlc3RzXG4vLyBjb25zdCBvMSA9IHFyKCd0ZXN0JywgJ2FzY2lpJyk7XG4vLyBjb25zdCBvMiA9IHFyKCd0ZXN0JywgJ3JhdycpO1xuLy8gY29uc3QgbzMgPSBxcigndGVzdCcsICdnaWYnKTtcbi8vIGNvbnN0IG80ID0gcXIoJ3Rlc3QnLCAnc3ZnJyk7XG4vLyBjb25zdCBvNSA9IHFyKCd0ZXN0JywgJ3Rlcm0nKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/qr@0.5.3/node_modules/qr/index.js\n");

/***/ })

};
;